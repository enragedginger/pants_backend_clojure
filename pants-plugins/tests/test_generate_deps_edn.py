from __future__ import annotations

from textwrap import dedent

import pytest

from pants_backend_clojure.goals.generate_deps import (
    GenerateDepsEdn,
    LockFileEntry,
    _repo_name_from_url,
    format_deps_edn,
    format_deps_edn_deps,
    format_mvn_repos,
    parse_lock_file,
)
from pants_backend_clojure.goals.generate_deps import rules as generate_deps_edn_rules
from pants_backend_clojure.namespace_analysis import rules as namespace_analysis_rules
from pants_backend_clojure.target_types import (
    ClojureSourcesGeneratorTarget,
    ClojureSourceTarget,
    ClojureTestsGeneratorTarget,
    ClojureTestTarget,
)
from pants_backend_clojure.target_types import rules as target_types_rules
from pants.backend.java.target_types import JavaSourcesGeneratorTarget
from pants.core.util_rules import config_files, external_tool, source_files, stripped_source_files, system_binaries
from pants.engine.rules import QueryRule
from pants.engine.target import AllTargets
from pants.jvm import classpath, jvm_common, non_jvm_dependencies
from pants.jvm.goals import lockfile
from pants.jvm.resolve.coursier_fetch import rules as coursier_fetch_rules
from pants.jvm.resolve.coursier_setup import rules as coursier_setup_rules
from pants.jvm.target_types import JvmArtifactTarget
from pants.jvm.util_rules import rules as jdk_util_rules
from pants.testutil.rule_runner import PYTHON_BOOTSTRAP_ENV, RuleRunner

from pants_backend_clojure import compile_clj


@pytest.fixture
def rule_runner() -> RuleRunner:
    rule_runner = RuleRunner(
        preserve_tmpdirs=True,
        rules=[
            *classpath.rules(),
            *compile_clj.rules(),
            *config_files.rules(),
            *coursier_fetch_rules(),
            *coursier_setup_rules(),
            *external_tool.rules(),
            *generate_deps_edn_rules(),
            *jdk_util_rules(),
            *jvm_common.rules(),
            *lockfile.rules(),
            *namespace_analysis_rules(),
            *non_jvm_dependencies.rules(),
            *source_files.rules(),
            *stripped_source_files.rules(),
            *system_binaries.rules(),
            *target_types_rules(),
            # Additional rule imports needed for integration tests
            QueryRule(AllTargets, []),
        ],
        target_types=[
            ClojureSourceTarget,
            ClojureSourcesGeneratorTarget,
            ClojureTestTarget,
            ClojureTestsGeneratorTarget,
            JvmArtifactTarget,
            JavaSourcesGeneratorTarget,
        ],
    )
    return rule_runner


_JVM_RESOLVES = {
    "jvm-default": "3rdparty/jvm/default.lock",
    "java21": "locks/jvm/java21.lock",
}

_CLOJURE_LOCKFILE = dedent(
    """\
    # This lockfile was autogenerated by Pants. To regenerate, run:
    #
    #    pants generate-lockfiles
    #
    # --- BEGIN PANTS LOCKFILE METADATA: DO NOT EDIT OR REMOVE ---
    # {
    #   "version": 1,
    #   "generated_with_requirements": [
    #     "org.clojure:clojure:1.12.3,url=not_provided,jar=not_provided"
    #   ]
    # }
    # --- END PANTS LOCKFILE METADATA ---

    [[entries]]
    file_name = "org.clojure_clojure_1.12.3.jar"
    [[entries.directDependencies]]
    group = "org.clojure"
    artifact = "core.specs.alpha"
    version = "0.4.74"
    packaging = "jar"

    [[entries.directDependencies]]
    group = "org.clojure"
    artifact = "spec.alpha"
    version = "0.5.238"
    packaging = "jar"

    [[entries.dependencies]]
    group = "org.clojure"
    artifact = "core.specs.alpha"
    version = "0.4.74"
    packaging = "jar"

    [[entries.dependencies]]
    group = "org.clojure"
    artifact = "spec.alpha"
    version = "0.5.238"
    packaging = "jar"


    [entries.coord]
    group = "org.clojure"
    artifact = "clojure"
    version = "1.12.3"
    packaging = "jar"
    [entries.file_digest]
    fingerprint = "cb2a1a3db1c2cd76ef4fa4a545d5a65f10b1b48b7f7672f0a109f5476f057166"
    serialized_bytes_length = 4230055
    [[entries]]
    file_name = "org.clojure_core.specs.alpha_0.4.74.jar"
    [[entries.directDependencies]]
    group = "org.clojure"
    artifact = "clojure"
    version = "1.12.3"
    packaging = "jar"

    [[entries.dependencies]]
    group = "org.clojure"
    artifact = "clojure"
    version = "1.12.3"
    packaging = "jar"


    [entries.coord]
    group = "org.clojure"
    artifact = "core.specs.alpha"
    version = "0.4.74"
    packaging = "jar"
    [entries.file_digest]
    fingerprint = "eb73ac08cf49ba840c88ba67beef11336ca554333d9408808d78946e0feb9ddb"
    serialized_bytes_length = 4306
    [[entries]]
    file_name = "org.clojure_spec.alpha_0.5.238.jar"
    [[entries.directDependencies]]
    group = "org.clojure"
    artifact = "clojure"
    version = "1.12.3"
    packaging = "jar"

    [[entries.dependencies]]
    group = "org.clojure"
    artifact = "clojure"
    version = "1.12.3"
    packaging = "jar"


    [entries.coord]
    group = "org.clojure"
    artifact = "spec.alpha"
    version = "0.5.238"
    packaging = "jar"
    [entries.file_digest]
    fingerprint = "94cd99b6ea639641f37af4860a643b6ed399ee5a8be5d717cff0b663c8d75077"
    serialized_bytes_length = 636643
    """
)


def test_parse_lock_file() -> None:
    """Test parsing a Pants TOML lock file."""
    entries = parse_lock_file(_CLOJURE_LOCKFILE)

    assert len(entries) == 3

    # Check first entry
    assert entries[0].group == "org.clojure"
    assert entries[0].artifact == "clojure"
    assert entries[0].version == "1.12.3"
    assert entries[0].packaging == "jar"

    # Check that all expected artifacts are present
    artifacts = {(e.group, e.artifact) for e in entries}
    assert ("org.clojure", "clojure") in artifacts
    assert ("org.clojure", "core.specs.alpha") in artifacts
    assert ("org.clojure", "spec.alpha") in artifacts


def test_parse_lock_file_with_minimal_entry() -> None:
    """Test parsing lock file with minimal required fields."""
    minimal_lock = dedent(
        """\
        [[entries]]
        [entries.coord]
        group = "com.example"
        artifact = "test"
        version = "1.0.0"
        """
    )

    entries = parse_lock_file(minimal_lock)
    assert len(entries) == 1
    assert entries[0].group == "com.example"
    assert entries[0].artifact == "test"
    assert entries[0].version == "1.0.0"
    assert entries[0].packaging == "jar"


def test_parse_lock_file_empty() -> None:
    """Test parsing an empty lock file."""
    empty_lock = "# Empty lock file\n"
    entries = parse_lock_file(empty_lock)
    assert len(entries) == 0


def test_format_deps_edn_deps() -> None:
    """Test formatting lock entries as deps.edn :deps map."""
    entries = [
        LockFileEntry(group="org.clojure", artifact="clojure", version="1.12.3"),
        LockFileEntry(group="com.google.guava", artifact="guava", version="33.0.0-jre"),
    ]

    result = format_deps_edn_deps(entries)

    # Check structure
    assert result.startswith("{")
    assert result.endswith("}")

    # Check content (order is alphabetical by group/artifact)
    assert 'com.google.guava/guava {:mvn/version "33.0.0-jre" :exclusions [*/*]}' in result
    assert 'org.clojure/clojure {:mvn/version "1.12.3" :exclusions [*/*]}' in result

    # Verify :exclusions [*/*] is present
    assert ":exclusions [*/*]" in result


def test_format_deps_edn_deps_empty() -> None:
    """Test formatting empty deps list."""
    result = format_deps_edn_deps([])
    assert result == "{}"


def test_format_deps_edn_deps_sorting() -> None:
    """Test that dependencies are sorted alphabetically."""
    entries = [
        LockFileEntry(group="zzz", artifact="last", version="1.0.0"),
        LockFileEntry(group="aaa", artifact="first", version="1.0.0"),
        LockFileEntry(group="mmm", artifact="middle", version="1.0.0"),
    ]

    result = format_deps_edn_deps(entries)
    lines = result.split("\n")

    # Extract dependency keys to verify order
    dep_keys = [line.strip().split()[0] for line in lines if line.strip() and not line.strip() in ["{", "}"]]
    assert dep_keys == ["aaa/first", "mmm/middle", "zzz/last"]


def test_format_deps_edn_deps_handles_duplicate_artifacts() -> None:
    """Test that duplicate group/artifact entries are deduplicated.

    If duplicate entries exist (same group/artifact but different versions),
    only the first one encountered after sorting should be kept.
    This provides deterministic output.
    """
    entries = [
        LockFileEntry(group="org.clojure", artifact="clojure", version="1.12.3"),
        LockFileEntry(group="org.clojure", artifact="clojure", version="1.11.0"),  # Duplicate
        LockFileEntry(group="com.google.guava", artifact="guava", version="33.0.0-jre"),
        LockFileEntry(group="com.google.guava", artifact="guava", version="32.0.0-jre"),  # Duplicate
    ]

    result = format_deps_edn_deps(entries)

    # Count occurrences of each dependency key
    clojure_count = result.count("org.clojure/clojure")
    guava_count = result.count("com.google.guava/guava")

    assert clojure_count == 1, f"Expected 1 org.clojure/clojure entry, found {clojure_count}"
    assert guava_count == 1, f"Expected 1 com.google.guava/guava entry, found {guava_count}"

    # Verify that the first version (after sorting by group/artifact) is kept
    # The sort is by (group, artifact) only, so within duplicates, original order is preserved
    # (Python's sort is stable). We should have 1.12.3 for clojure (first in input)
    # and 33.0.0-jre for guava (first in input)
    assert '1.12.3' in result, "Expected version 1.12.3 (first occurrence in input list)"
    assert '33.0.0-jre' in result, "Expected version 33.0.0-jre (first occurrence in input list)"
    assert '1.11.0' not in result, "Should not contain duplicate version 1.11.0"
    assert '32.0.0-jre' not in result, "Should not contain duplicate version 32.0.0-jre"


def test_format_deps_edn_deps_duplicate_same_version() -> None:
    """Test that duplicate entries with identical versions produce single entry."""
    entries = [
        LockFileEntry(group="org.clojure", artifact="clojure", version="1.12.3"),
        LockFileEntry(group="org.clojure", artifact="clojure", version="1.12.3"),  # Exact duplicate
        LockFileEntry(group="org.clojure", artifact="clojure", version="1.12.3"),  # Another duplicate
    ]

    result = format_deps_edn_deps(entries)

    # Should have exactly one entry
    clojure_count = result.count("org.clojure/clojure")
    assert clojure_count == 1, f"Expected 1 org.clojure/clojure entry, found {clojure_count}"

    # Verify the correct version is present
    assert '1.12.3' in result


def test_format_deps_edn_complete() -> None:
    """Test formatting a complete deps.edn file."""
    from pants_backend_clojure.goals.generate_deps import ClojureSourcesInfo

    sources_info = ClojureSourcesInfo(
        source_paths={"projects/foo/src", "projects/bar/src"},
        test_paths={"projects/foo/test", "projects/bar/test"},
    )

    deps_entries = [
        LockFileEntry(group="org.clojure", artifact="clojure", version="1.12.3"),
    ]

    result = format_deps_edn(sources_info, deps_entries, "java21")

    # Check structure
    assert "Generated by Pants" in result
    assert ":paths" in result
    assert ":deps" in result
    assert ":aliases" in result

    # Check source paths
    assert "projects/foo/src" in result or "projects/bar/src" in result

    # Check test alias
    assert ":test" in result
    assert "projects/foo/test" in result or "projects/bar/test" in result

    # Check nREPL alias
    assert ":nrepl" in result
    assert 'nrepl/nrepl {:mvn/version "1.4.0"' in result

    # Check rebel alias
    assert ":rebel" in result
    assert 'com.bhauman/rebel-readline {:mvn/version "0.1.4"' in result

    # Check dependency format
    assert 'org.clojure/clojure {:mvn/version "1.12.3" :exclusions [*/*]}' in result


def test_format_deps_edn_no_test_paths() -> None:
    """Test formatting deps.edn when there are no test paths."""
    from pants_backend_clojure.goals.generate_deps import ClojureSourcesInfo

    sources_info = ClojureSourcesInfo(
        source_paths={"src"},
        test_paths=set(),
    )

    deps_entries = [
        LockFileEntry(group="org.clojure", artifact="clojure", version="1.12.3"),
    ]

    result = format_deps_edn(sources_info, deps_entries, "java21")

    # Should still have :test alias, but with empty paths
    assert ":test" in result
    assert ":aliases" in result


def test_format_deps_edn_no_source_paths() -> None:
    """Test formatting deps.edn when there are no source paths."""
    from pants_backend_clojure.goals.generate_deps import ClojureSourcesInfo

    sources_info = ClojureSourcesInfo(
        source_paths=set(),
        test_paths={"test"},
    )

    deps_entries = []

    result = format_deps_edn(sources_info, deps_entries, "java21")

    # Should have empty :paths
    assert ":paths []" in result

    # Should have :test alias with test paths
    assert ":test" in result
    assert "test" in result


def test_repo_name_from_url_clojars() -> None:
    """Test that Clojars URLs get 'clojars' name."""
    assert _repo_name_from_url("https://repo.clojars.org/") == "clojars"
    assert _repo_name_from_url("https://clojars.org/repo/") == "clojars"
    assert _repo_name_from_url("http://CLOJARS.org/") == "clojars"


def test_repo_name_from_url_central() -> None:
    """Test that Maven Central URLs get 'central' name."""
    assert _repo_name_from_url("https://repo1.maven.org/maven2") == "central"
    assert _repo_name_from_url("https://maven-central.storage-download.googleapis.com/maven2") == "central"
    assert _repo_name_from_url("https://REPO1.MAVEN.ORG/maven2/") == "central"


def test_repo_name_from_url_custom() -> None:
    """Test that custom repo URLs use hostname."""
    assert _repo_name_from_url("https://my-company.jfrog.io/artifactory/") == "my-company-jfrog-io"
    assert _repo_name_from_url("https://nexus.example.com:8081/repository/maven/") == "nexus-example-com-8081"


def test_format_mvn_repos_empty() -> None:
    """Test that empty repos list returns empty map."""
    assert format_mvn_repos([]) == "{}"
    assert format_mvn_repos(()) == "{}"


def test_format_mvn_repos_single() -> None:
    """Test formatting a single repository."""
    repos = ["https://repo.clojars.org/"]
    result = format_mvn_repos(repos)

    assert '"clojars"' in result
    assert ':url "https://repo.clojars.org/"' in result


def test_format_mvn_repos_multiple() -> None:
    """Test formatting multiple repositories."""
    repos = [
        "https://repo.clojars.org/",
        "https://repo1.maven.org/maven2",
    ]
    result = format_mvn_repos(repos)

    assert '"clojars"' in result
    assert '"central"' in result
    assert ':url "https://repo.clojars.org/"' in result
    assert ':url "https://repo1.maven.org/maven2"' in result


def test_format_mvn_repos_collision_handling() -> None:
    """Test that duplicate repo names get unique suffixes."""
    repos = [
        "https://repo1.maven.org/maven2",
        "https://maven-central.storage-download.googleapis.com/maven2",
    ]
    result = format_mvn_repos(repos)

    # First central gets "central", second gets "central-1"
    assert '"central"' in result
    assert '"central-1"' in result


def test_format_deps_edn_with_repos() -> None:
    """Test formatting deps.edn with repository configuration."""
    from pants_backend_clojure.goals.generate_deps import ClojureSourcesInfo

    sources_info = ClojureSourcesInfo(
        source_paths={"src"},
        test_paths=set(),
    )

    deps_entries = [
        LockFileEntry(group="org.clojure", artifact="clojure", version="1.12.3"),
    ]

    repos = (
        "https://repo.clojars.org/",
        "https://repo1.maven.org/maven2",
    )

    result = format_deps_edn(sources_info, deps_entries, "java21", repos=repos)

    # Check :mvn/repos section is present
    assert ":mvn/repos" in result
    assert '"clojars"' in result
    assert '"central"' in result
    assert ':url "https://repo.clojars.org/"' in result
    assert ':url "https://repo1.maven.org/maven2"' in result


def test_format_deps_edn_no_repos() -> None:
    """Test that :mvn/repos is omitted when repos is None or empty."""
    from pants_backend_clojure.goals.generate_deps import ClojureSourcesInfo

    sources_info = ClojureSourcesInfo(
        source_paths={"src"},
        test_paths=set(),
    )

    deps_entries = []

    # Test with None
    result = format_deps_edn(sources_info, deps_entries, "java21", repos=None)
    assert ":mvn/repos" not in result

    # Test with empty list
    result = format_deps_edn(sources_info, deps_entries, "java21", repos=[])
    assert ":mvn/repos" not in result


def test_lock_file_entry_defaults() -> None:
    """Test LockFileEntry default values."""
    entry = LockFileEntry(group="com.example", artifact="test", version="1.0.0")

    assert entry.group == "com.example"
    assert entry.artifact == "test"
    assert entry.version == "1.0.0"
    assert entry.packaging == "jar"


def test_lock_file_entry_custom_packaging() -> None:
    """Test LockFileEntry with custom packaging."""
    entry = LockFileEntry(
        group="com.example", artifact="test", version="1.0.0", packaging="pom"
    )

    assert entry.packaging == "pom"


# Integration test: Generate deps.edn for a simple project
def test_generate_deps_edn_simple_project(rule_runner: RuleRunner) -> None:
    """Test generating deps.edn for a simple Clojure project."""
    rule_runner.write_files(
        {
            "3rdparty/jvm/BUILD": dedent(
                """\
                jvm_artifact(
                    name="org.clojure_clojure",
                    group="org.clojure",
                    artifact="clojure",
                    version="1.12.3",
                )
                """
            ),
            "3rdparty/jvm/default.lock": _CLOJURE_LOCKFILE,
            "BUILD": dedent(
                """\
                clojure_sources(
                    name='lib',
                    dependencies=[
                        '3rdparty/jvm:org.clojure_clojure',
                    ],
                )
                """
            ),
            "example.clj": dedent(
                """\
                (ns example)

                (defn greet [name]
                  (str "Hello, " name "!"))
                """
            ),
        }
    )

    args = [
        f"--jvm-resolves={repr(_JVM_RESOLVES)}",
        "--jvm-default-resolve=jvm-default",
    ]
    rule_runner.set_options(args, env_inherit=PYTHON_BOOTSTRAP_ENV)

    # Run the goal
    result = rule_runner.run_goal_rule(
        GenerateDepsEdn,
        args=["--generate-deps-edn-resolve=jvm-default"],
        env_inherit=PYTHON_BOOTSTRAP_ENV,
    )

    # Check that the goal succeeded
    assert result.exit_code == 0


# Integration test: Generate deps.edn with multiple source directories
def test_generate_deps_edn_multiple_sources(rule_runner: RuleRunner) -> None:
    """Test generating deps.edn with multiple source directories."""
    rule_runner.write_files(
        {
            "3rdparty/jvm/BUILD": dedent(
                """\
                jvm_artifact(
                    name="org.clojure_clojure",
                    group="org.clojure",
                    artifact="clojure",
                    version="1.12.3",
                )
                """
            ),
            "3rdparty/jvm/default.lock": _CLOJURE_LOCKFILE,
            "foo/BUILD": dedent(
                """\
                clojure_sources(
                    name='lib',
                    dependencies=[
                        '3rdparty/jvm:org.clojure_clojure',
                    ],
                )
                """
            ),
            "foo/foo.clj": dedent(
                """\
                (ns foo)

                (defn foo-fn [] "foo")
                """
            ),
            "bar/BUILD": dedent(
                """\
                clojure_sources(
                    name='lib',
                    dependencies=[
                        '3rdparty/jvm:org.clojure_clojure',
                    ],
                )
                """
            ),
            "bar/bar.clj": dedent(
                """\
                (ns bar)

                (defn bar-fn [] "bar")
                """
            ),
        }
    )

    args = [
        f"--jvm-resolves={repr(_JVM_RESOLVES)}",
        "--jvm-default-resolve=jvm-default",
    ]
    rule_runner.set_options(args, env_inherit=PYTHON_BOOTSTRAP_ENV)

    # Run the goal
    result = rule_runner.run_goal_rule(
        GenerateDepsEdn,
        args=["--generate-deps-edn-resolve=jvm-default"],
        env_inherit=PYTHON_BOOTSTRAP_ENV,
    )

    # Check that the goal succeeded
    assert result.exit_code == 0


# Integration test: Generate deps.edn with test sources
def test_generate_deps_edn_with_tests(rule_runner: RuleRunner) -> None:
    """Test generating deps.edn that includes test sources."""
    rule_runner.write_files(
        {
            "3rdparty/jvm/BUILD": dedent(
                """\
                jvm_artifact(
                    name="org.clojure_clojure",
                    group="org.clojure",
                    artifact="clojure",
                    version="1.12.3",
                )
                """
            ),
            "3rdparty/jvm/default.lock": _CLOJURE_LOCKFILE,
            "src/BUILD": dedent(
                """\
                clojure_sources(
                    name='lib',
                    dependencies=[
                        '3rdparty/jvm:org.clojure_clojure',
                    ],
                )
                """
            ),
            "src/example.clj": dedent(
                """\
                (ns example)

                (defn greet [name]
                  (str "Hello, " name "!"))
                """
            ),
            "test/BUILD": dedent(
                """\
                clojure_tests(
                    name='tests',
                    dependencies=[
                        'src:lib',
                        '3rdparty/jvm:org.clojure_clojure',
                    ],
                )
                """
            ),
            "test/example_test.clj": dedent(
                """\
                (ns example-test
                  (:require [clojure.test :refer [deftest is]]
                            [example :refer [greet]]))

                (deftest test-greet
                  (is (= "Hello, World!" (greet "World"))))
                """
            ),
        }
    )

    args = [
        f"--jvm-resolves={repr(_JVM_RESOLVES)}",
        "--jvm-default-resolve=jvm-default",
    ]
    rule_runner.set_options(args, env_inherit=PYTHON_BOOTSTRAP_ENV)

    # Run the goal
    result = rule_runner.run_goal_rule(
        GenerateDepsEdn,
        args=["--generate-deps-edn-resolve=jvm-default"],
        env_inherit=PYTHON_BOOTSTRAP_ENV,
    )

    # Check that the goal succeeded
    assert result.exit_code == 0


def test_parse_lock_file_invalid_toml() -> None:
    """Test that parsing invalid TOML raises an error."""
    invalid_lock = "this is not valid TOML [[["

    with pytest.raises(ValueError, match="Failed to parse lock file"):
        parse_lock_file(invalid_lock)


def test_format_deps_edn_deps_special_characters() -> None:
    """Test formatting dependencies with special characters in version."""
    entries = [
        LockFileEntry(
            group="com.example", artifact="lib", version="1.0.0-alpha+build.123"
        ),
    ]

    result = format_deps_edn_deps(entries)

    assert 'com.example/lib {:mvn/version "1.0.0-alpha+build.123" :exclusions [*/*]}' in result


def test_generate_deps_edn_nested_source_dirs(rule_runner: RuleRunner) -> None:
    """Test that source roots are correctly detected for nested directory structures.

    This tests the bug where source roots were incorrectly set to the BUILD file's
    directory instead of the actual source root (e.g., sub-project instead of sub-project/src).
    """
    import re

    rule_runner.write_files(
        {
            "3rdparty/jvm/BUILD": dedent(
                """\
                jvm_artifact(
                    name="org.clojure_clojure",
                    group="org.clojure",
                    artifact="clojure",
                    version="1.12.3",
                )
                """
            ),
            "3rdparty/jvm/default.lock": _CLOJURE_LOCKFILE,
            "sub-project/BUILD": dedent(
                """\
                clojure_sources(
                    name='lib',
                    sources=["src/**/*.clj"],
                    dependencies=[
                        '3rdparty/jvm:org.clojure_clojure',
                    ],
                )
                clojure_tests(
                    name='tests',
                    sources=["test/**/*.clj"],
                    dependencies=[
                        ':lib',
                        '3rdparty/jvm:org.clojure_clojure',
                    ],
                )
                """
            ),
            "sub-project/src/myapp/core.clj": dedent(
                """\
                (ns myapp.core)

                (defn greet [name]
                  (str "Hello, " name "!"))
                """
            ),
            "sub-project/test/myapp/core_test.clj": dedent(
                """\
                (ns myapp.core-test
                  (:require [clojure.test :refer [deftest is]]
                            [myapp.core :refer [greet]]))

                (deftest test-greet
                  (is (= "Hello, World!" (greet "World"))))
                """
            ),
        }
    )

    args = [
        f"--jvm-resolves={repr(_JVM_RESOLVES)}",
        "--jvm-default-resolve=jvm-default",
    ]
    rule_runner.set_options(args, env_inherit=PYTHON_BOOTSTRAP_ENV)

    # Run the goal
    result = rule_runner.run_goal_rule(
        GenerateDepsEdn,
        args=["--generate-deps-edn-resolve=jvm-default"],
        env_inherit=PYTHON_BOOTSTRAP_ENV,
    )

    assert result.exit_code == 0

    # Read and verify the generated deps.edn content
    from pathlib import Path
    deps_edn_path = Path(rule_runner.build_root) / "deps.edn"
    deps_edn_content = deps_edn_path.read_text()

    # Verify source paths contain the correct nested path
    assert "sub-project/src" in deps_edn_content, (
        f"Expected 'sub-project/src' in :paths, got: {deps_edn_content}"
    )

    # Verify test paths contain the correct nested path
    assert "sub-project/test" in deps_edn_content, (
        f"Expected 'sub-project/test' in :test :extra-paths, got: {deps_edn_content}"
    )

    # Verify we DON'T have the incorrect parent directory
    # Check that "sub-project" alone (not followed by /src or /test) is not in paths
    # Match "sub-project" that's not followed by /src or /test
    incorrect_path_pattern = r'"sub-project"(?!/(?:src|test))'
    assert not re.search(incorrect_path_pattern, deps_edn_content), (
        f"Found incorrect path 'sub-project' without /src or /test suffix: {deps_edn_content}"
    )
