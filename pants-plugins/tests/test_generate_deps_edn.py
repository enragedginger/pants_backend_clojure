from __future__ import annotations

from textwrap import dedent

import pytest

from clojure_backend.goals.generate_deps import (
    GenerateDepsEdn,
    LockFileEntry,
    format_deps_edn,
    format_deps_edn_deps,
    parse_lock_file,
)
from clojure_backend.goals.generate_deps import rules as generate_deps_edn_rules
from clojure_backend.target_types import (
    ClojureSourcesGeneratorTarget,
    ClojureSourceTarget,
    ClojureTestsGeneratorTarget,
    ClojureTestTarget,
)
from clojure_backend.target_types import rules as target_types_rules
from pants.backend.java.target_types import JavaSourcesGeneratorTarget
from pants.core.util_rules import config_files, source_files, stripped_source_files, system_binaries
from pants.engine.rules import QueryRule
from pants.engine.target import AllTargets
from pants.jvm import classpath, jvm_common, non_jvm_dependencies
from pants.jvm.goals import lockfile
from pants.jvm.resolve.coursier_fetch import rules as coursier_fetch_rules
from pants.jvm.resolve.coursier_setup import rules as coursier_setup_rules
from pants.jvm.target_types import JvmArtifactTarget
from pants.jvm.util_rules import rules as jdk_util_rules
from pants.testutil.rule_runner import PYTHON_BOOTSTRAP_ENV, RuleRunner

from clojure_backend import compile_clj


@pytest.fixture
def rule_runner() -> RuleRunner:
    rule_runner = RuleRunner(
        preserve_tmpdirs=True,
        rules=[
            *classpath.rules(),
            *compile_clj.rules(),
            *config_files.rules(),
            *coursier_fetch_rules(),
            *coursier_setup_rules(),
            *generate_deps_edn_rules(),
            *jdk_util_rules(),
            *jvm_common.rules(),
            *lockfile.rules(),
            *non_jvm_dependencies.rules(),
            *source_files.rules(),
            *stripped_source_files.rules(),
            *system_binaries.rules(),
            *target_types_rules(),
            # Additional rule imports needed for integration tests
            QueryRule(AllTargets, []),
        ],
        target_types=[
            ClojureSourceTarget,
            ClojureSourcesGeneratorTarget,
            ClojureTestTarget,
            ClojureTestsGeneratorTarget,
            JvmArtifactTarget,
            JavaSourcesGeneratorTarget,
        ],
    )
    return rule_runner


_JVM_RESOLVES = {
    "jvm-default": "3rdparty/jvm/default.lock",
    "java21": "locks/jvm/java21.lock",
}

_CLOJURE_LOCKFILE = dedent(
    """\
    # This lockfile was autogenerated by Pants. To regenerate, run:
    #
    #    pants generate-lockfiles
    #
    # --- BEGIN PANTS LOCKFILE METADATA: DO NOT EDIT OR REMOVE ---
    # {
    #   "version": 1,
    #   "generated_with_requirements": [
    #     "org.clojure:clojure:1.12.0,url=not_provided,jar=not_provided"
    #   ]
    # }
    # --- END PANTS LOCKFILE METADATA ---

    [[entries]]
    file_name = "org.clojure_clojure_1.12.0.jar"
    [[entries.directDependencies]]
    group = "org.clojure"
    artifact = "core.specs.alpha"
    version = "0.4.74"
    packaging = "jar"

    [[entries.directDependencies]]
    group = "org.clojure"
    artifact = "spec.alpha"
    version = "0.5.238"
    packaging = "jar"

    [[entries.dependencies]]
    group = "org.clojure"
    artifact = "core.specs.alpha"
    version = "0.4.74"
    packaging = "jar"

    [[entries.dependencies]]
    group = "org.clojure"
    artifact = "spec.alpha"
    version = "0.5.238"
    packaging = "jar"


    [entries.coord]
    group = "org.clojure"
    artifact = "clojure"
    version = "1.12.0"
    packaging = "jar"
    [entries.file_digest]
    fingerprint = "c45333006441a059ea9fdb1341fc6c1f40b921a10dccd82665311e48a0384763"
    serialized_bytes_length = 4227052
    [[entries]]
    file_name = "org.clojure_core.specs.alpha_0.4.74.jar"
    [[entries.directDependencies]]
    group = "org.clojure"
    artifact = "clojure"
    version = "1.12.0"
    packaging = "jar"

    [[entries.dependencies]]
    group = "org.clojure"
    artifact = "clojure"
    version = "1.12.0"
    packaging = "jar"


    [entries.coord]
    group = "org.clojure"
    artifact = "core.specs.alpha"
    version = "0.4.74"
    packaging = "jar"
    [entries.file_digest]
    fingerprint = "eb73ac08cf49ba840c88ba67beef11336ca554333d9408808d78946e0feb9ddb"
    serialized_bytes_length = 4306
    [[entries]]
    file_name = "org.clojure_spec.alpha_0.5.238.jar"
    [[entries.directDependencies]]
    group = "org.clojure"
    artifact = "clojure"
    version = "1.12.0"
    packaging = "jar"

    [[entries.dependencies]]
    group = "org.clojure"
    artifact = "clojure"
    version = "1.12.0"
    packaging = "jar"


    [entries.coord]
    group = "org.clojure"
    artifact = "spec.alpha"
    version = "0.5.238"
    packaging = "jar"
    [entries.file_digest]
    fingerprint = "94cd99b6ea639641f37af4860a643b6ed399ee5a8be5d717cff0b663c8d75077"
    serialized_bytes_length = 636643
    """
)


def test_parse_lock_file() -> None:
    """Test parsing a Pants TOML lock file."""
    entries = parse_lock_file(_CLOJURE_LOCKFILE)

    assert len(entries) == 3

    # Check first entry
    assert entries[0].group == "org.clojure"
    assert entries[0].artifact == "clojure"
    assert entries[0].version == "1.12.0"
    assert entries[0].packaging == "jar"

    # Check that all expected artifacts are present
    artifacts = {(e.group, e.artifact) for e in entries}
    assert ("org.clojure", "clojure") in artifacts
    assert ("org.clojure", "core.specs.alpha") in artifacts
    assert ("org.clojure", "spec.alpha") in artifacts


def test_parse_lock_file_with_minimal_entry() -> None:
    """Test parsing lock file with minimal required fields."""
    minimal_lock = dedent(
        """\
        [[entries]]
        [entries.coord]
        group = "com.example"
        artifact = "test"
        version = "1.0.0"
        """
    )

    entries = parse_lock_file(minimal_lock)
    assert len(entries) == 1
    assert entries[0].group == "com.example"
    assert entries[0].artifact == "test"
    assert entries[0].version == "1.0.0"
    assert entries[0].packaging == "jar"


def test_parse_lock_file_empty() -> None:
    """Test parsing an empty lock file."""
    empty_lock = "# Empty lock file\n"
    entries = parse_lock_file(empty_lock)
    assert len(entries) == 0


def test_format_deps_edn_deps() -> None:
    """Test formatting lock entries as deps.edn :deps map."""
    entries = [
        LockFileEntry(group="org.clojure", artifact="clojure", version="1.12.0"),
        LockFileEntry(group="com.google.guava", artifact="guava", version="33.0.0-jre"),
    ]

    result = format_deps_edn_deps(entries)

    # Check structure
    assert result.startswith("{")
    assert result.endswith("}")

    # Check content (order is alphabetical by group/artifact)
    assert 'com.google.guava/guava {:mvn/version "33.0.0-jre" :exclusions [*]}' in result
    assert 'org.clojure/clojure {:mvn/version "1.12.0" :exclusions [*]}' in result

    # Verify :exclusions [*] is present
    assert ":exclusions [*]" in result


def test_format_deps_edn_deps_empty() -> None:
    """Test formatting empty deps list."""
    result = format_deps_edn_deps([])
    assert result == "{}"


def test_format_deps_edn_deps_sorting() -> None:
    """Test that dependencies are sorted alphabetically."""
    entries = [
        LockFileEntry(group="zzz", artifact="last", version="1.0.0"),
        LockFileEntry(group="aaa", artifact="first", version="1.0.0"),
        LockFileEntry(group="mmm", artifact="middle", version="1.0.0"),
    ]

    result = format_deps_edn_deps(entries)
    lines = result.split("\n")

    # Extract dependency keys to verify order
    dep_keys = [line.strip().split()[0] for line in lines if line.strip() and not line.strip() in ["{", "}"]]
    assert dep_keys == ["aaa/first", "mmm/middle", "zzz/last"]


def test_format_deps_edn_complete() -> None:
    """Test formatting a complete deps.edn file."""
    from clojure_backend.goals.generate_deps import ClojureSourcesInfo

    sources_info = ClojureSourcesInfo(
        source_paths={"projects/foo/src", "projects/bar/src"},
        test_paths={"projects/foo/test", "projects/bar/test"},
    )

    deps_entries = [
        LockFileEntry(group="org.clojure", artifact="clojure", version="1.12.0"),
    ]

    result = format_deps_edn(sources_info, deps_entries, "java21")

    # Check structure
    assert "Generated by Pants" in result
    assert ":paths" in result
    assert ":deps" in result
    assert ":aliases" in result

    # Check source paths
    assert "projects/foo/src" in result or "projects/bar/src" in result

    # Check test alias
    assert ":test" in result
    assert "projects/foo/test" in result or "projects/bar/test" in result

    # Check nREPL alias
    assert ":nrepl" in result
    assert 'nrepl/nrepl {:mvn/version "1.4.0"' in result

    # Check rebel alias
    assert ":rebel" in result
    assert 'com.bhauman/rebel-readline {:mvn/version "0.1.4"' in result

    # Check dependency format
    assert 'org.clojure/clojure {:mvn/version "1.12.0" :exclusions [*]}' in result


def test_format_deps_edn_no_test_paths() -> None:
    """Test formatting deps.edn when there are no test paths."""
    from clojure_backend.goals.generate_deps import ClojureSourcesInfo

    sources_info = ClojureSourcesInfo(
        source_paths={"src"},
        test_paths=set(),
    )

    deps_entries = [
        LockFileEntry(group="org.clojure", artifact="clojure", version="1.12.0"),
    ]

    result = format_deps_edn(sources_info, deps_entries, "java21")

    # Should still have :test alias, but with empty paths
    assert ":test" in result
    assert ":aliases" in result


def test_format_deps_edn_no_source_paths() -> None:
    """Test formatting deps.edn when there are no source paths."""
    from clojure_backend.goals.generate_deps import ClojureSourcesInfo

    sources_info = ClojureSourcesInfo(
        source_paths=set(),
        test_paths={"test"},
    )

    deps_entries = []

    result = format_deps_edn(sources_info, deps_entries, "java21")

    # Should have empty :paths
    assert ":paths []" in result

    # Should have :test alias with test paths
    assert ":test" in result
    assert "test" in result


def test_lock_file_entry_defaults() -> None:
    """Test LockFileEntry default values."""
    entry = LockFileEntry(group="com.example", artifact="test", version="1.0.0")

    assert entry.group == "com.example"
    assert entry.artifact == "test"
    assert entry.version == "1.0.0"
    assert entry.packaging == "jar"


def test_lock_file_entry_custom_packaging() -> None:
    """Test LockFileEntry with custom packaging."""
    entry = LockFileEntry(
        group="com.example", artifact="test", version="1.0.0", packaging="pom"
    )

    assert entry.packaging == "pom"


# Integration test: Generate deps.edn for a simple project
def test_generate_deps_edn_simple_project(rule_runner: RuleRunner) -> None:
    """Test generating deps.edn for a simple Clojure project."""
    rule_runner.write_files(
        {
            "3rdparty/jvm/BUILD": dedent(
                """\
                jvm_artifact(
                    name="org.clojure_clojure",
                    group="org.clojure",
                    artifact="clojure",
                    version="1.12.0",
                )
                """
            ),
            "3rdparty/jvm/default.lock": _CLOJURE_LOCKFILE,
            "BUILD": dedent(
                """\
                clojure_sources(
                    name='lib',
                    dependencies=[
                        '3rdparty/jvm:org.clojure_clojure',
                    ],
                )
                """
            ),
            "example.clj": dedent(
                """\
                (ns example)

                (defn greet [name]
                  (str "Hello, " name "!"))
                """
            ),
        }
    )

    args = [
        f"--jvm-resolves={repr(_JVM_RESOLVES)}",
        "--jvm-default-resolve=jvm-default",
    ]
    rule_runner.set_options(args, env_inherit=PYTHON_BOOTSTRAP_ENV)

    # Run the goal
    result = rule_runner.run_goal_rule(
        GenerateDepsEdn,
        args=["--generate-deps-edn-resolve=jvm-default"],
        env_inherit=PYTHON_BOOTSTRAP_ENV,
    )

    # Check that the goal succeeded
    assert result.exit_code == 0


# Integration test: Generate deps.edn with multiple source directories
def test_generate_deps_edn_multiple_sources(rule_runner: RuleRunner) -> None:
    """Test generating deps.edn with multiple source directories."""
    rule_runner.write_files(
        {
            "3rdparty/jvm/BUILD": dedent(
                """\
                jvm_artifact(
                    name="org.clojure_clojure",
                    group="org.clojure",
                    artifact="clojure",
                    version="1.12.0",
                )
                """
            ),
            "3rdparty/jvm/default.lock": _CLOJURE_LOCKFILE,
            "foo/BUILD": dedent(
                """\
                clojure_sources(
                    name='lib',
                    dependencies=[
                        '3rdparty/jvm:org.clojure_clojure',
                    ],
                )
                """
            ),
            "foo/foo.clj": dedent(
                """\
                (ns foo)

                (defn foo-fn [] "foo")
                """
            ),
            "bar/BUILD": dedent(
                """\
                clojure_sources(
                    name='lib',
                    dependencies=[
                        '3rdparty/jvm:org.clojure_clojure',
                    ],
                )
                """
            ),
            "bar/bar.clj": dedent(
                """\
                (ns bar)

                (defn bar-fn [] "bar")
                """
            ),
        }
    )

    args = [
        f"--jvm-resolves={repr(_JVM_RESOLVES)}",
        "--jvm-default-resolve=jvm-default",
    ]
    rule_runner.set_options(args, env_inherit=PYTHON_BOOTSTRAP_ENV)

    # Run the goal
    result = rule_runner.run_goal_rule(
        GenerateDepsEdn,
        args=["--generate-deps-edn-resolve=jvm-default"],
        env_inherit=PYTHON_BOOTSTRAP_ENV,
    )

    # Check that the goal succeeded
    assert result.exit_code == 0


# Integration test: Generate deps.edn with test sources
def test_generate_deps_edn_with_tests(rule_runner: RuleRunner) -> None:
    """Test generating deps.edn that includes test sources."""
    rule_runner.write_files(
        {
            "3rdparty/jvm/BUILD": dedent(
                """\
                jvm_artifact(
                    name="org.clojure_clojure",
                    group="org.clojure",
                    artifact="clojure",
                    version="1.12.0",
                )
                """
            ),
            "3rdparty/jvm/default.lock": _CLOJURE_LOCKFILE,
            "src/BUILD": dedent(
                """\
                clojure_sources(
                    name='lib',
                    dependencies=[
                        '3rdparty/jvm:org.clojure_clojure',
                    ],
                )
                """
            ),
            "src/example.clj": dedent(
                """\
                (ns example)

                (defn greet [name]
                  (str "Hello, " name "!"))
                """
            ),
            "test/BUILD": dedent(
                """\
                clojure_tests(
                    name='tests',
                    dependencies=[
                        'src:lib',
                        '3rdparty/jvm:org.clojure_clojure',
                    ],
                )
                """
            ),
            "test/example_test.clj": dedent(
                """\
                (ns example-test
                  (:require [clojure.test :refer [deftest is]]
                            [example :refer [greet]]))

                (deftest test-greet
                  (is (= "Hello, World!" (greet "World"))))
                """
            ),
        }
    )

    args = [
        f"--jvm-resolves={repr(_JVM_RESOLVES)}",
        "--jvm-default-resolve=jvm-default",
    ]
    rule_runner.set_options(args, env_inherit=PYTHON_BOOTSTRAP_ENV)

    # Run the goal
    result = rule_runner.run_goal_rule(
        GenerateDepsEdn,
        args=["--generate-deps-edn-resolve=jvm-default"],
        env_inherit=PYTHON_BOOTSTRAP_ENV,
    )

    # Check that the goal succeeded
    assert result.exit_code == 0


def test_parse_lock_file_invalid_toml() -> None:
    """Test that parsing invalid TOML raises an error."""
    invalid_lock = "this is not valid TOML [[["

    with pytest.raises(ValueError, match="Failed to parse lock file"):
        parse_lock_file(invalid_lock)


def test_format_deps_edn_deps_special_characters() -> None:
    """Test formatting dependencies with special characters in version."""
    entries = [
        LockFileEntry(
            group="com.example", artifact="lib", version="1.0.0-alpha+build.123"
        ),
    ]

    result = format_deps_edn_deps(entries)

    assert 'com.example/lib {:mvn/version "1.0.0-alpha+build.123" :exclusions [*]}' in result
