from __future__ import annotations

from textwrap import dedent

import pytest

from clojure_backend.clj_repl import ClojureNRepl, ClojureRepl
from clojure_backend.clj_repl import rules as repl_rules
from clojure_backend.target_types import (
    ClojureSourcesGeneratorTarget,
    ClojureSourceTarget,
    ClojureTestsGeneratorTarget,
    ClojureTestTarget,
)
from clojure_backend.target_types import rules as target_types_rules
from clojure_backend import compile_clj
from pants.backend.java.target_types import JavaSourcesGeneratorTarget
from pants.core.goals.repl import ReplRequest
from pants.core.util_rules import config_files, source_files, stripped_source_files, system_binaries
from pants.engine.addresses import Address
from pants.engine.rules import QueryRule
from pants.jvm import classpath, jvm_common, non_jvm_dependencies
from pants.jvm.goals import lockfile
from pants.jvm.resolve.coursier_fetch import rules as coursier_fetch_rules
from pants.jvm.resolve.coursier_setup import rules as coursier_setup_rules
from pants.jvm.target_types import JvmArtifactTarget
from pants.jvm.util_rules import rules as jdk_util_rules
from pants.testutil.rule_runner import PYTHON_BOOTSTRAP_ENV, QueryRule, RuleRunner


@pytest.fixture
def rule_runner() -> RuleRunner:
    rule_runner = RuleRunner(
        preserve_tmpdirs=True,
        rules=[
            *classpath.rules(),
            *compile_clj.rules(),
            *config_files.rules(),
            *coursier_fetch_rules(),
            *coursier_setup_rules(),
            *jdk_util_rules(),
            *jvm_common.rules(),
            *non_jvm_dependencies.rules(),
            *source_files.rules(),
            *stripped_source_files.rules(),
            *system_binaries.rules(),
            *target_types_rules(),
            *repl_rules(),
            *lockfile.rules(),
            QueryRule(ReplRequest, [ClojureRepl]),
            QueryRule(ReplRequest, [ClojureNRepl]),
        ],
        target_types=[
            ClojureSourceTarget,
            ClojureSourcesGeneratorTarget,
            ClojureTestTarget,
            ClojureTestsGeneratorTarget,
            JvmArtifactTarget,
            JavaSourcesGeneratorTarget,
        ],
    )
    return rule_runner


_JVM_RESOLVES = {
    "jvm-default": "3rdparty/jvm/default.lock",
}

_CLOJURE_LOCKFILE = dedent(
    """\
    # This lockfile was autogenerated by Pants. To regenerate, run:
    #
    #    pants generate-lockfiles
    #
    # --- BEGIN PANTS LOCKFILE METADATA: DO NOT EDIT OR REMOVE ---
    # {
    #   "version": 1,
    #   "generated_with_requirements": [
    #     "org.clojure:clojure:1.12.0,url=not_provided,jar=not_provided"
    #   ]
    # }
    # --- END PANTS LOCKFILE METADATA ---

    [[entries]]
    file_name = "org.clojure_clojure_1.12.0.jar"
    [[entries.directDependencies]]
    group = "org.clojure"
    artifact = "core.specs.alpha"
    version = "0.4.74"
    packaging = "jar"

    [[entries.directDependencies]]
    group = "org.clojure"
    artifact = "spec.alpha"
    version = "0.5.238"
    packaging = "jar"

    [[entries.dependencies]]
    group = "org.clojure"
    artifact = "core.specs.alpha"
    version = "0.4.74"
    packaging = "jar"

    [[entries.dependencies]]
    group = "org.clojure"
    artifact = "spec.alpha"
    version = "0.5.238"
    packaging = "jar"


    [entries.coord]
    group = "org.clojure"
    artifact = "clojure"
    version = "1.12.0"
    packaging = "jar"
    [entries.file_digest]
    fingerprint = "c45333006441a059ea9fdb1341fc6c1f40b921a10dccd82665311e48a0384763"
    serialized_bytes_length = 4227052
    [[entries]]
    file_name = "org.clojure_core.specs.alpha_0.4.74.jar"
    [[entries.directDependencies]]
    group = "org.clojure"
    artifact = "clojure"
    version = "1.12.0"
    packaging = "jar"

    [[entries.dependencies]]
    group = "org.clojure"
    artifact = "clojure"
    version = "1.12.0"
    packaging = "jar"


    [entries.coord]
    group = "org.clojure"
    artifact = "core.specs.alpha"
    version = "0.4.74"
    packaging = "jar"
    [entries.file_digest]
    fingerprint = "eb73ac08cf49ba840c88ba67beef11336ca554333d9408808d78946e0feb9ddb"
    serialized_bytes_length = 4306
    [[entries]]
    file_name = "org.clojure_spec.alpha_0.5.238.jar"
    [[entries.directDependencies]]
    group = "org.clojure"
    artifact = "clojure"
    version = "1.12.0"
    packaging = "jar"

    [[entries.dependencies]]
    group = "org.clojure"
    artifact = "clojure"
    version = "1.12.0"
    packaging = "jar"


    [entries.coord]
    group = "org.clojure"
    artifact = "spec.alpha"
    version = "0.5.238"
    packaging = "jar"
    [entries.file_digest]
    fingerprint = "94cd99b6ea639641f37af4860a643b6ed399ee5a8be5d717cff0b663c8d75077"
    serialized_bytes_length = 636643
    """
)


def test_repl_request_includes_clojure_main(rule_runner: RuleRunner) -> None:
    """Test that REPL request includes clojure.main command."""
    rule_runner.write_files(
        {
            "3rdparty/jvm/BUILD": dedent(
                """\
                jvm_artifact(
                    name="org.clojure_clojure",
                    group="org.clojure",
                    artifact="clojure",
                    version="1.12.0",
                )
                """
            ),
            "3rdparty/jvm/default.lock": _CLOJURE_LOCKFILE,
            "BUILD": dedent(
                """\
                clojure_sources(
                    name='lib',
                    dependencies=[
                        '3rdparty/jvm:org.clojure_clojure',
                    ],
                )
                """
            ),
            "example.clj": dedent(
                """\
                (ns example)

                (defn greet [name]
                  (str "Hello, " name "!"))
                """
            ),
        }
    )

    args = [
        f"--jvm-resolves={repr(_JVM_RESOLVES)}",
        "--jvm-default-resolve=jvm-default",
    ]
    rule_runner.set_options(args, env_inherit=PYTHON_BOOTSTRAP_ENV)

    tgt = rule_runner.get_target(
        Address(spec_path="", target_name="lib", relative_file_path="example.clj")
    )

    repl = ClojureRepl(targets=(tgt,))
    request = rule_runner.request(ReplRequest, [repl])

    # Verify command includes clojure.main
    assert "clojure.main" in request.args
    assert "--repl" in request.args

    # Verify runs in workspace
    assert request.run_in_workspace is True


def test_repl_request_includes_source_files(rule_runner: RuleRunner) -> None:
    """Test that REPL request includes project source files."""
    rule_runner.write_files(
        {
            "3rdparty/jvm/BUILD": dedent(
                """\
                jvm_artifact(
                    name="org.clojure_clojure",
                    group="org.clojure",
                    artifact="clojure",
                    version="1.12.0",
                )
                """
            ),
            "3rdparty/jvm/default.lock": _CLOJURE_LOCKFILE,
            "BUILD": dedent(
                """\
                clojure_sources(
                    name='lib',
                    dependencies=[
                        '3rdparty/jvm:org.clojure_clojure',
                    ],
                )
                """
            ),
            "example.clj": dedent(
                """\
                (ns example)

                (defn add [x y]
                  (+ x y))
                """
            ),
        }
    )

    args = [
        f"--jvm-resolves={repr(_JVM_RESOLVES)}",
        "--jvm-default-resolve=jvm-default",
    ]
    rule_runner.set_options(args, env_inherit=PYTHON_BOOTSTRAP_ENV)

    tgt = rule_runner.get_target(
        Address(spec_path="", target_name="lib", relative_file_path="example.clj")
    )

    repl = ClojureRepl(targets=(tgt,))
    request = rule_runner.request(ReplRequest, [repl])

    # Verify digest is not empty (contains source files and dependencies)
    assert request.digest != None
    assert request.digest.fingerprint != ""

    # Verify JDK environment is set up
    assert request.extra_env is not None
    assert len(request.immutable_input_digests) > 0


def test_repl_request_includes_dependencies(rule_runner: RuleRunner) -> None:
    """Test that REPL request includes dependencies in classpath."""
    rule_runner.write_files(
        {
            "3rdparty/jvm/BUILD": dedent(
                """\
                jvm_artifact(
                    name="org.clojure_clojure",
                    group="org.clojure",
                    artifact="clojure",
                    version="1.12.0",
                )
                """
            ),
            "3rdparty/jvm/default.lock": _CLOJURE_LOCKFILE,
            "BUILD": dedent(
                """\
                clojure_sources(
                    name='lib',
                    dependencies=[
                        '3rdparty/jvm:org.clojure_clojure',
                    ],
                )
                """
            ),
            "example.clj": dedent(
                """\
                (ns example)

                (defn identity-fn [x] x)
                """
            ),
        }
    )

    args = [
        f"--jvm-resolves={repr(_JVM_RESOLVES)}",
        "--jvm-default-resolve=jvm-default",
    ]
    rule_runner.set_options(args, env_inherit=PYTHON_BOOTSTRAP_ENV)

    tgt = rule_runner.get_target(
        Address(spec_path="", target_name="lib", relative_file_path="example.clj")
    )

    repl = ClojureRepl(targets=(tgt,))
    request = rule_runner.request(ReplRequest, [repl])

    # Verify classpath includes current directory
    assert "." in request.args or any("." in str(arg) for arg in request.args)

    # Verify command structure is correct
    assert len(request.args) > 0
    assert request.args[-2] == "clojure.main"
    assert request.args[-1] == "--repl"


def test_repl_request_with_test_sources(rule_runner: RuleRunner) -> None:
    """Test that REPL request can include test sources."""
    rule_runner.write_files(
        {
            "3rdparty/jvm/BUILD": dedent(
                """\
                jvm_artifact(
                    name="org.clojure_clojure",
                    group="org.clojure",
                    artifact="clojure",
                    version="1.12.0",
                )
                """
            ),
            "3rdparty/jvm/default.lock": _CLOJURE_LOCKFILE,
            "src/BUILD": dedent(
                """\
                clojure_sources(
                    name='lib',
                    dependencies=[
                        '3rdparty/jvm:org.clojure_clojure',
                    ],
                )
                """
            ),
            "src/example.clj": dedent(
                """\
                (ns example)

                (defn greet [name]
                  (str "Hello, " name "!"))
                """
            ),
            "test/BUILD": dedent(
                """\
                clojure_tests(
                    name='tests',
                    dependencies=[
                        'src:lib',
                        '3rdparty/jvm:org.clojure_clojure',
                    ],
                )
                """
            ),
            "test/example_test.clj": dedent(
                """\
                (ns example-test
                  (:require [clojure.test :refer [deftest is]]
                            [example :refer [greet]]))

                (deftest test-greet
                  (is (= "Hello, World!" (greet "World"))))
                """
            ),
        }
    )

    args = [
        f"--jvm-resolves={repr(_JVM_RESOLVES)}",
        "--jvm-default-resolve=jvm-default",
    ]
    rule_runner.set_options(args, env_inherit=PYTHON_BOOTSTRAP_ENV)

    # Get test target
    test_tgt = rule_runner.get_target(
        Address(spec_path="test", target_name="tests", relative_file_path="example_test.clj")
    )

    repl = ClojureRepl(targets=(test_tgt,))
    request = rule_runner.request(ReplRequest, [repl])

    # Verify REPL request is created successfully
    assert "clojure.main" in request.args
    assert "--repl" in request.args
    assert request.run_in_workspace is True


def test_repl_request_with_multiple_targets(rule_runner: RuleRunner) -> None:
    """Test that REPL request can handle multiple targets."""
    rule_runner.write_files(
        {
            "3rdparty/jvm/BUILD": dedent(
                """\
                jvm_artifact(
                    name="org.clojure_clojure",
                    group="org.clojure",
                    artifact="clojure",
                    version="1.12.0",
                )
                """
            ),
            "3rdparty/jvm/default.lock": _CLOJURE_LOCKFILE,
            "foo/BUILD": dedent(
                """\
                clojure_sources(
                    name='lib',
                    dependencies=[
                        '3rdparty/jvm:org.clojure_clojure',
                    ],
                )
                """
            ),
            "foo/foo.clj": dedent(
                """\
                (ns foo)

                (defn foo-fn [] "foo")
                """
            ),
            "bar/BUILD": dedent(
                """\
                clojure_sources(
                    name='lib',
                    dependencies=[
                        '3rdparty/jvm:org.clojure_clojure',
                    ],
                )
                """
            ),
            "bar/bar.clj": dedent(
                """\
                (ns bar)

                (defn bar-fn [] "bar")
                """
            ),
        }
    )

    args = [
        f"--jvm-resolves={repr(_JVM_RESOLVES)}",
        "--jvm-default-resolve=jvm-default",
    ]
    rule_runner.set_options(args, env_inherit=PYTHON_BOOTSTRAP_ENV)

    # Get both targets
    foo_tgt = rule_runner.get_target(
        Address(spec_path="foo", target_name="lib", relative_file_path="foo.clj")
    )
    bar_tgt = rule_runner.get_target(
        Address(spec_path="bar", target_name="lib", relative_file_path="bar.clj")
    )

    repl = ClojureRepl(targets=(foo_tgt, bar_tgt))
    request = rule_runner.request(ReplRequest, [repl])

    # Verify REPL request is created successfully with multiple targets
    assert "clojure.main" in request.args
    assert "--repl" in request.args
    assert request.run_in_workspace is True
    assert request.digest != None


# NOTE: nREPL tests are skipped because they require fetching the nREPL artifact
# from Maven repositories, which may not be accessible in the test environment.
# The nREPL implementation is functional and can be tested manually with:
#   pants repl --repl-shell=nrepl <target-spec>

# @pytest.mark.skip(reason="Requires nREPL artifact from Maven Central")
# def test_nrepl_request_includes_nrepl_server(rule_runner: RuleRunner) -> None:
#     """Test that nREPL request includes nREPL server startup command."""
#     # Test implementation available but skipped due to Maven repository dependency
