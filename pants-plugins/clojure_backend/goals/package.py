from __future__ import annotations

import io
import logging
import os
import re
import zipfile
from dataclasses import dataclass

logger = logging.getLogger(__name__)

from pants.core.goals.package import (
    BuiltPackage,
    BuiltPackageArtifact,
    OutputPathField,
    PackageFieldSet,
)
from pants.core.util_rules.source_files import SourceFiles, SourceFilesRequest
from pants.core.util_rules.stripped_source_files import StrippedSourceFiles
from pants.engine.addresses import Addresses
from pants.engine.fs import CreateDigest, Digest, DigestContents, EMPTY_DIGEST, FileContent, MergeDigests
from pants.engine.internals.selectors import Get, MultiGet
from pants.engine.rules import collect_rules, rule
from pants.engine.target import (
    TransitiveTargets,
    TransitiveTargetsRequest,
)
from pants.engine.unions import UnionRule
from pants.jvm.classpath import Classpath
from pants.jvm.subsystems import JvmSubsystem
from pants.jvm.target_types import JvmJdkField, JvmResolveField
from pants.util.frozendict import FrozenDict
from pants.util.logging import LogLevel

from clojure_backend.aot_compile import (
    CompileClojureAOTRequest,
    CompiledClojureClasses,
)
from clojure_backend.namespace_analysis import (
    ClojureNamespaceAnalysis,
    ClojureNamespaceAnalysisRequest,
)
from clojure_backend.provided_dependencies import (
    ProvidedDependencies,
    ResolveProvidedDependenciesRequest,
)
from clojure_backend.target_types import (
    ClojureProvidedDependenciesField,
    ClojureMainNamespaceField,
    ClojureSourceField,
    ClojureTestSourceField,
)


@dataclass(frozen=True)
class ClojureDeployJarFieldSet(PackageFieldSet):
    """FieldSet for packaging a clojure_deploy_jar target."""

    required_fields = (
        ClojureMainNamespaceField,
        JvmResolveField,
    )

    main: ClojureMainNamespaceField
    provided: ClojureProvidedDependenciesField
    jdk: JvmJdkField
    resolve: JvmResolveField
    output_path: OutputPathField


@rule(desc="Package Clojure deploy jar", level=LogLevel.DEBUG)
async def package_clojure_deploy_jar(
    field_set: ClojureDeployJarFieldSet,
    jvm: JvmSubsystem,
) -> BuiltPackage:
    """Package a Clojure application into an executable JAR with AOT compilation.

    This rule:
    1. AOT compiles the main namespace transitively (or skips AOT for clojure.main)
    2. Validates the main namespace has (:gen-class) if AOT compiling
    3. Packages all dependencies into a single executable JAR
    """

    main_namespace = field_set.main.value

    # Check for source-only mode (using clojure.main)
    skip_aot = main_namespace == "clojure.main"

    # Get transitive targets to find all Clojure sources
    transitive_targets = await Get(
        TransitiveTargets,
        TransitiveTargetsRequest([field_set.address]),
    )

    # Find all Clojure source targets in dependencies
    clojure_source_targets = [
        tgt
        for tgt in transitive_targets.dependencies
        if tgt.has_field(ClojureSourceField) or tgt.has_field(ClojureTestSourceField)
    ]

    # Get all source files for analysis
    source_fields = []
    for tgt in clojure_source_targets:
        if tgt.has_field(ClojureSourceField):
            source_fields.append(tgt[ClojureSourceField])
        elif tgt.has_field(ClojureTestSourceField):
            source_fields.append(tgt[ClojureTestSourceField])

    # Get source files and analyze namespaces using clj-kondo
    if source_fields:
        source_files = await Get(
            SourceFiles,
            SourceFilesRequest(source_fields),
        )
        # Analyze all source files in batch using clj-kondo
        namespace_analysis = await Get(
            ClojureNamespaceAnalysis,
            ClojureNamespaceAnalysisRequest(source_files.snapshot),
        )
        digest_contents = await Get(DigestContents, Digest, source_files.snapshot.digest)
    else:
        namespace_analysis = ClojureNamespaceAnalysis(
            namespaces=FrozenDict({}),
            requires=FrozenDict({}),
            imports=FrozenDict({}),
        )
        digest_contents = []

    # Build set of first-party namespace paths for filtering AOT classes
    # These represent namespaces from clojure_source targets in the project
    first_party_namespace_paths: set[str] = set()
    for source_path, namespace in namespace_analysis.namespaces.items():
        # Convert namespace to class path: my.app.core -> my/app/core
        # Clojure converts hyphens to underscores in class names
        namespace_path = namespace.replace('.', '/').replace('-', '_')
        first_party_namespace_paths.add(namespace_path)

    logger.debug(f"First-party namespaces: {first_party_namespace_paths}")

    # Also track gen-class :name declarations from all first-party sources
    # This ensures classes generated by (:gen-class :name X) are included in the JAR
    first_party_gen_class_paths: set[str] = set()

    for file_content in digest_contents:
        source_content = file_content.content.decode("utf-8")
        # Look for (:gen-class ... :name X) pattern
        # The pattern handles :name appearing anywhere within the gen-class form
        gen_class_name_match = re.search(
            r'\(:gen-class\s+(?:[^)]*?\s)?:name\s+([a-zA-Z][\w.]*)',
            source_content,
            re.DOTALL,
        )
        if gen_class_name_match:
            class_name = gen_class_name_match.group(1)
            # Convert com.example.MyApp -> com/example/MyApp
            class_path = class_name.replace('.', '/')
            first_party_gen_class_paths.add(class_path)

    logger.debug(f"First-party gen-class names: {first_party_gen_class_paths}")

    # Determine which namespaces to compile
    if skip_aot:
        namespaces_to_compile: tuple[str, ...] = ()
    else:
        # Always compile just the main namespace - transitive compilation handles deps
        namespaces_to_compile = (main_namespace,)

    # Only validate gen-class if we're doing AOT compilation
    # Source-only JARs (main=clojure.main) don't need gen-class validation
    if skip_aot:
        # Source-only mode with clojure.main
        main_class_name = "clojure.main"
    else:
        # Find the source file for main namespace using the analysis result
        # Build reverse mapping: namespace -> file path
        namespace_to_file = {ns: path for path, ns in namespace_analysis.namespaces.items()}
        main_source_path = namespace_to_file.get(main_namespace)
        main_source_file = None

        if main_source_path:
            # Find the file content for the main source
            for file_content in digest_contents:
                if file_content.path == main_source_path:
                    main_source_file = file_content.content.decode("utf-8")
                    break

        if not main_source_file:
            raise ValueError(
                f"Could not find source file for main namespace '{main_namespace}'.\n\n"
                f"Common causes:\n"
                f"  - Main namespace is not in the dependencies of this target\n"
                f"  - Namespace name doesn't match the file path\n"
                f"  - Missing (ns {main_namespace}) declaration in source file\n\n"
                f"Troubleshooting:\n"
                f"  1. Verify dependencies: pants dependencies {field_set.address}\n"
                f"  2. Check file contains (ns {main_namespace}) declaration\n"
                f"  3. Ensure the namespace follows Clojure naming conventions\n"
            )

        main_class_name = main_namespace
        # Check for (:gen-class) in the namespace declaration
        # Use a more robust check that looks for gen-class in the ns form, not just anywhere
        # This regex looks for (ns ...) followed by gen-class before the closing paren
        # It handles multi-line ns declarations with multiple clauses
        ns_with_gen_class = re.search(
            r'\(ns\s+[\w.-]+.*?\(:gen-class',
            main_source_file,
            re.DOTALL,
        )

        if not ns_with_gen_class:
            raise ValueError(
                f"Main namespace '{main_namespace}' must include (:gen-class) in its ns declaration "
                f"to be used as an entry point for an executable JAR.\n\n"
                f"Example:\n"
                f"(ns {main_namespace}\n"
                f"  (:gen-class))\n\n"
                f"(defn -main [& args]\n"
                f"  (println \"Hello, World!\"))"
            )

        # Get the main class name from the gen-class declaration
        # Look for (:gen-class ... :name CustomClassName)
        # The pattern handles :name appearing anywhere within the gen-class form
        gen_class_name_match = re.search(
            r'\(:gen-class\s+(?:[^)]*?\s)?:name\s+([a-zA-Z][\w.]*)',
            main_source_file,
            re.DOTALL,
        )

        if gen_class_name_match:
            main_class_name = gen_class_name_match.group(1)

    # Get provided dependencies to exclude from the JAR
    # Pass the resolve name so Maven transitives can be looked up in the lockfile
    resolve_name = field_set.resolve.normalized_value(jvm)
    provided_deps = await Get(
        ProvidedDependencies,
        ResolveProvidedDependenciesRequest(field_set.provided, resolve_name),
    )

    # Build full address set for AOT compilation (includes everything)
    all_source_addresses = Addresses(tgt.address for tgt in clojure_source_targets)

    # Build runtime address set for JAR packaging (excludes provided and their transitives)
    runtime_source_addresses = Addresses(
        addr for addr in all_source_addresses
        if addr not in provided_deps.addresses
    )

    # Get runtime classpath and compiled classes
    # Note: AOT compilation uses ALL addresses (including provided)
    #       JAR packaging uses RUNTIME addresses (excluding provided)
    if skip_aot:
        # No AOT - get classpath only, use empty digest for compiled classes
        runtime_classpath = await Get(Classpath, Addresses, runtime_source_addresses)
        compiled_classes = CompiledClojureClasses(
            digest=EMPTY_DIGEST,
            classpath_entry=None,
        )
    else:
        runtime_classpath, compiled_classes = await MultiGet(
            Get(Classpath, Addresses, runtime_source_addresses),
            Get(
                CompiledClojureClasses,
                CompileClojureAOTRequest(
                    namespaces=namespaces_to_compile,
                    source_addresses=all_source_addresses,  # AOT needs all deps
                    jdk=field_set.jdk,
                    resolve=field_set.resolve,
                ),
            ),
        )

    # Determine output filename
    output_filename = field_set.output_path.value_or_default(
        file_ending="jar",
    )

    # Build set of namespaces for provided dependencies to exclude from JAR
    # Collect all source fields for provided targets
    provided_source_fields = []
    for tgt in clojure_source_targets:
        if tgt.address in provided_deps.addresses:
            if tgt.has_field(ClojureSourceField):
                provided_source_fields.append(tgt[ClojureSourceField])
            elif tgt.has_field(ClojureTestSourceField):
                provided_source_fields.append(tgt[ClojureTestSourceField])

    # Get all source files and analyze namespaces
    provided_namespaces: set[str] = set()
    provided_namespace_paths: set[str] = set()
    if provided_source_fields:
        provided_source_files = await Get(
            SourceFiles,
            SourceFilesRequest(provided_source_fields),
        )
        if provided_source_files.files:
            # Analyze provided source files using clj-kondo
            provided_analysis = await Get(
                ClojureNamespaceAnalysis,
                ClojureNamespaceAnalysisRequest(provided_source_files.snapshot),
            )
            provided_namespaces = set(provided_analysis.namespaces.values())
            # Convert namespaces to class paths for filtering AOT classes
            for namespace in provided_namespaces:
                namespace_path = namespace.replace('.', '/').replace('-', '_')
                provided_namespace_paths.add(namespace_path)

    def is_provided_class(arcname: str) -> bool:
        """Check if a class file belongs to a provided dependency namespace."""
        if not provided_namespace_paths:
            return False
        # Remove .class extension
        class_path = arcname[:-6]  # len('.class') == 6
        # Handle inner classes (split on $) and __init classes
        base_class_path = class_path.split('$')[0]
        if base_class_path.endswith('__init'):
            base_class_path = base_class_path[:-6]  # len('__init') == 6
        return base_class_path in provided_namespace_paths

    def is_first_party_class(arcname: str) -> bool:
        """Check if a class file belongs to a first-party namespace or gen-class."""
        if not first_party_namespace_paths:
            return True  # Fallback: include all if no analysis available

        class_path = arcname[:-6]  # Remove .class
        base_class_path = class_path.split('$')[0]  # Handle inner classes
        if base_class_path.endswith('__init'):
            base_class_path = base_class_path[:-6]

        # Check namespace paths (handles init, fn, record, protocol classes)
        if base_class_path in first_party_namespace_paths:
            return True

        # Check gen-class :name paths (exact match for custom named classes)
        # Note: gen-class :name classes don't have inner classes or __init suffix
        if class_path in first_party_gen_class_paths:
            return True

        return False

    # Create JAR manifest
    if skip_aot:
        # Source-only JAR using clojure.main as entry point
        manifest_content = """\
Manifest-Version: 1.0
Main-Class: clojure.main
Created-By: Pants Build System
X-Source-Only: true
"""
    else:
        # Standard manifest with executable main class
        manifest_content = f"""\
Manifest-Version: 1.0
Main-Class: {main_class_name}
Created-By: Pants Build System
"""

    # Get the contents of compiled classes and dependency JARs
    # Note: Uses runtime_classpath which excludes compile-only dependencies
    all_digests = [compiled_classes.digest, *runtime_classpath.digests()]
    merged_digest = await Get(Digest, MergeDigests(all_digests))
    digest_contents = await Get(DigestContents, Digest, merged_digest)

    # For source-only JARs, get first-party source files with stripped source roots
    stripped_source_contents: list = []
    if skip_aot:
        # Get source files for first-party targets (excluding provided)
        first_party_source_fields = [
            tgt[ClojureSourceField] if tgt.has_field(ClojureSourceField)
            else tgt[ClojureTestSourceField]
            for tgt in clojure_source_targets
            if tgt.address not in provided_deps.addresses
        ]

        if first_party_source_fields:
            # Get stripped version (removes source roots like src/)
            stripped_sources = await Get(
                StrippedSourceFiles,
                SourceFilesRequest(
                    first_party_source_fields,
                    for_sources_types=(ClojureSourceField, ClojureTestSourceField),
                ),
            )
            stripped_source_contents = await Get(
                DigestContents, Digest, stripped_sources.snapshot.digest
            )

    # Create the uberjar in memory using Python's zipfile module
    jar_buffer = io.BytesIO()
    with zipfile.ZipFile(jar_buffer, 'w', zipfile.ZIP_DEFLATED) as jar:
        # Write manifest first (uncompressed as per JAR spec)
        jar.writestr('META-INF/MANIFEST.MF', manifest_content, compress_type=zipfile.ZIP_STORED)

        # Track what we've added to avoid duplicates
        added_entries = {'META-INF/MANIFEST.MF'}

        # Build set of artifact prefixes to exclude based on coordinates
        # Pants/Coursier JAR filenames follow: {group}_{artifact}_{version}.jar pattern
        # e.g., "org.clojure_clojure_1.11.0.jar" for org.clojure:clojure:1.11.0
        excluded_artifact_prefixes = set()
        for group, artifact in provided_deps.coordinates:
            excluded_artifact_prefixes.add(f"{group}_{artifact}_")

        # Step 1: Add ONLY first-party AOT-compiled classes
        # Third-party AOT output is discarded - their content comes from JARs
        # Provided Clojure source dependencies are excluded (they're compile-only)
        first_party_count = 0
        third_party_skipped = 0

        for file_content in digest_contents:
            if file_content.path.startswith('classes/') and file_content.path.endswith('.class'):
                arcname = file_content.path[8:]  # len('classes/') == 8
                # Skip classes belonging to provided Clojure source dependencies
                if is_provided_class(arcname):
                    continue
                # Only include first-party classes from AOT
                # Third-party content comes from JARs (whether .class or .clj files)
                if is_first_party_class(arcname):
                    jar.writestr(arcname, file_content.content)
                    added_entries.add(arcname)
                    first_party_count += 1
                else:
                    third_party_skipped += 1

        logger.info(f"AOT: included {first_party_count} first-party classes, "
                    f"skipped {third_party_skipped} third-party classes")

        # Step 1.5: Add first-party source files when skip_aot=True
        # (When AOT is enabled, first-party sources are compiled to classes)
        if skip_aot and stripped_source_contents:
            source_count = 0
            for file_content in stripped_source_contents:
                arcname = file_content.path
                if arcname not in added_entries:
                    jar.writestr(arcname, file_content.content)
                    added_entries.add(arcname)
                    source_count += 1

            logger.info(f"Added {source_count} first-party source files for source-only JAR")

        # Step 2: Extract dependency JARs
        # All third-party content comes from here (.class, .clj, resources)
        for file_content in digest_contents:
            if file_content.path.endswith('.jar'):
                jar_filename = os.path.basename(file_content.path)
                should_exclude = any(
                    jar_filename.startswith(prefix) for prefix in excluded_artifact_prefixes
                )
                if should_exclude:
                    continue

                try:
                    jar_bytes = io.BytesIO(file_content.content)
                    with zipfile.ZipFile(jar_bytes, 'r') as dep_jar:
                        for item in dep_jar.namelist():
                            # Skip META-INF (includes signatures, manifests)
                            if item.startswith('META-INF/'):
                                continue
                            # Skip LICENSE files at root level (can conflict between deps)
                            item_basename = os.path.basename(item).upper()
                            if item_basename.startswith('LICENSE'):
                                continue
                            if item in added_entries:
                                continue  # Already added from another JAR
                            try:
                                data = dep_jar.read(item)
                                jar.writestr(item, data)
                                added_entries.add(item)
                            except Exception:
                                pass
                except Exception:
                    pass

    # Validate that the manifest's Main-Class is actually in the JAR
    if not skip_aot:
        main_class_path = main_class_name.replace('.', '/') + '.class'
        if main_class_path not in added_entries:
            raise ValueError(
                f"Main class '{main_class_name}' was not found in the JAR.\n\n"
                f"This usually means:\n"
                f"  1. The namespace uses (:gen-class :name {main_class_name}) but the class wasn't detected\n"
                f"  2. The main namespace wasn't properly compiled\n\n"
                f"Expected class file: {main_class_path}\n"
                f"First-party namespace paths: {sorted(first_party_namespace_paths)}\n"
                f"First-party gen-class paths: {sorted(first_party_gen_class_paths)}\n\n"
                f"If using (:gen-class :name X), ensure the pattern is on a single line "
                f"and follows the format: (:gen-class :name fully.qualified.ClassName)"
            )

    # Create the output digest with the JAR file
    jar_bytes = jar_buffer.getvalue()
    output_digest = await Get(
        Digest,
        CreateDigest([FileContent(output_filename, jar_bytes)]),
    )

    # Return the built JAR
    artifact = BuiltPackageArtifact(
        relpath=output_filename,
    )

    return BuiltPackage(
        digest=output_digest,
        artifacts=(artifact,),
    )


def rules():
    return [
        *collect_rules(),
        UnionRule(PackageFieldSet, ClojureDeployJarFieldSet),
    ]
