"""Clojure namespace to JVM artifact mapping.

This module provides a mapping from Clojure namespaces to jvm_artifact addresses,
enabling automatic dependency inference for third-party Clojure libraries.

Similar to Pants' SymbolMapping for Java classes, but specifically for Clojure
namespaces which have different semantics and file structure conventions.
"""

from __future__ import annotations

import hashlib
import json
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable

from pants.engine.addresses import Address
from pants.engine.fs import CreateDigest, Digest, DigestContents, FileContent, PathGlobs
from pants.engine.rules import Get, collect_rules, rule
from pants.util.frozendict import FrozenDict
from pants.util.logging import LogLevel


@dataclass(frozen=True)
class ClojureNamespaceMapping:
    """Mapping from Clojure namespaces to jvm_artifact addresses.

    This is similar to Pants' SymbolMapping but specifically for Clojure namespaces
    instead of Java classes. The mapping is built from metadata files that are
    generated by analyzing JAR contents.

    Attributes:
        mapping: Maps (namespace, resolve) -> tuple of addresses.
                 Multiple addresses indicate ambiguity (multiple artifacts provide
                 the same namespace).
        metadata_version: Version of the metadata format used to build this mapping.
    """
    mapping: FrozenDict[tuple[str, str], tuple[Address, ...]]
    metadata_version: str = "1.0"

    def addresses_for_namespace(
        self,
        namespace: str,
        resolve: str,
    ) -> tuple[Address, ...]:
        """Look up which jvm_artifact(s) provide a given Clojure namespace.

        Args:
            namespace: The Clojure namespace to look up (e.g., "clojure.data.json").
            resolve: The JVM resolve name (e.g., "default", "java17").

        Returns:
            Tuple of addresses that provide this namespace. Empty tuple if not found.
            Multiple addresses indicate ambiguity - the namespace is provided by
            multiple artifacts and needs disambiguation.

        Examples:
            >>> mapping.addresses_for_namespace("clojure.data.json", "default")
            (Address("3rdparty/jvm", target_name="data-json"),)

            >>> mapping.addresses_for_namespace("unknown.namespace", "default")
            ()

            >>> mapping.addresses_for_namespace("ambiguous.util", "default")
            (Address("3rdparty/jvm", target_name="lib-a"),
             Address("3rdparty/jvm", target_name="lib-b"))
        """
        return self.mapping.get((namespace, resolve), ())


@dataclass(frozen=True)
class ClojureNamespaceMetadataFile:
    """Request to load a Clojure namespace metadata file.

    Attributes:
        path: Path to the metadata JSON file (e.g., "3rdparty/jvm/default_clojure_namespaces.json").
    """
    path: str


@dataclass(frozen=True)
class ClojureNamespaceMetadata:
    """Parsed contents of a Clojure namespace metadata file.

    Attributes:
        resolve: The JVM resolve name this metadata is for.
        lockfile_hash: SHA256 hash of the lockfile when metadata was generated.
        artifacts: Map of Maven coordinate to artifact metadata.
    """
    resolve: str
    lockfile_hash: str
    artifacts: dict[str, ArtifactNamespaceMetadata]


@dataclass(frozen=True)
class ArtifactNamespaceMetadata:
    """Metadata about namespaces provided by a single artifact.

    Attributes:
        address: Pants address of the jvm_artifact target.
        namespaces: Clojure namespaces provided by this artifact.
        source: How the namespaces were determined ("jar-analysis", "manual", "heuristic").
    """
    address: str
    namespaces: tuple[str, ...]
    source: str = "jar-analysis"


@rule(desc="Load Clojure namespace metadata files", level=LogLevel.DEBUG)
async def load_clojure_namespace_mapping() -> ClojureNamespaceMapping:
    """Load Clojure namespace mappings from all metadata files.

    This rule finds all *_clojure_namespaces.json files in the repository
    and builds a unified mapping from namespaces to artifact addresses.

    The metadata files are typically located alongside JVM lockfiles:
        3rdparty/jvm/default.lock -> 3rdparty/jvm/default_clojure_namespaces.json
        3rdparty/jvm/java17.lock -> 3rdparty/jvm/java17_clojure_namespaces.json

    Returns:
        ClojureNamespaceMapping with all namespace->address mappings.
    """
    # Find all Clojure namespace metadata files
    # Pattern: **/*_clojure_namespaces.json
    metadata_files_digest = await Get(
        Digest,
        PathGlobs(["**/*_clojure_namespaces.json"]),
    )

    # Read all metadata files
    metadata_contents = await Get(DigestContents, Digest, metadata_files_digest)

    # If no metadata files found, return empty mapping
    if not metadata_contents:
        return ClojureNamespaceMapping(mapping=FrozenDict())

    # Build unified mapping
    mapping: dict[tuple[str, str], list[Address]] = {}

    for file_content in metadata_contents:
        try:
            metadata = _parse_metadata_file(file_content)

            # Add each artifact's namespaces to the mapping
            for coord, artifact_meta in metadata.artifacts.items():
                address = Address.parse(artifact_meta.address)

                for namespace in artifact_meta.namespaces:
                    key = (namespace, metadata.resolve)
                    if key not in mapping:
                        mapping[key] = []
                    mapping[key].append(address)

        except Exception as e:
            # Log warning but don't fail - just skip this metadata file
            # This allows builds to continue even with corrupted metadata
            import logging
            logging.warning(
                f"Failed to parse Clojure namespace metadata file {file_content.path}: {e}"
            )

    # Convert to frozen dict with tuple values
    frozen_mapping = FrozenDict({
        key: tuple(addresses)
        for key, addresses in mapping.items()
    })

    return ClojureNamespaceMapping(mapping=frozen_mapping)


def _parse_metadata_file(file_content: FileContent) -> ClojureNamespaceMetadata:
    """Parse a Clojure namespace metadata JSON file.

    Args:
        file_content: The metadata file content.

    Returns:
        Parsed ClojureNamespaceMetadata.

    Raises:
        ValueError: If the file is malformed or has invalid structure.
    """
    data = json.loads(file_content.content.decode('utf-8'))

    # Validate required fields
    if 'resolve' not in data:
        raise ValueError("Metadata file missing 'resolve' field")
    if 'artifacts' not in data:
        raise ValueError("Metadata file missing 'artifacts' field")

    # Parse artifact metadata
    artifacts = {}
    for coord, artifact_data in data['artifacts'].items():
        if 'address' not in artifact_data:
            raise ValueError(f"Artifact {coord} missing 'address' field")
        if 'namespaces' not in artifact_data:
            raise ValueError(f"Artifact {coord} missing 'namespaces' field")

        artifacts[coord] = ArtifactNamespaceMetadata(
            address=artifact_data['address'],
            namespaces=tuple(artifact_data['namespaces']),
            source=artifact_data.get('source', 'jar-analysis'),
        )

    return ClojureNamespaceMetadata(
        resolve=data['resolve'],
        lockfile_hash=data.get('lockfile_hash', ''),
        artifacts=artifacts,
    )


def create_metadata_file_content(
    resolve: str,
    lockfile_path: str,
    lockfile_digest: Digest,
    artifact_namespaces: dict[str, tuple[str, tuple[str, ...]]],
) -> FileContent:
    """Create a Clojure namespace metadata file.

    Args:
        resolve: The JVM resolve name.
        lockfile_path: Path to the lockfile this metadata is for.
        lockfile_digest: Digest of the lockfile (for staleness detection).
        artifact_namespaces: Map of Maven coordinate to (address, namespaces).

    Returns:
        FileContent for the metadata JSON file.
    """
    # Compute lockfile hash
    lockfile_hash = f"sha256:{lockfile_digest.fingerprint}"

    # Build artifacts metadata
    artifacts = {}
    for coord, (address, namespaces) in artifact_namespaces.items():
        artifacts[coord] = {
            "address": address,
            "namespaces": list(namespaces),
            "source": "jar-analysis",
        }

    # Build metadata structure
    metadata = {
        "version": "1.0",
        "resolve": resolve,
        "lockfile": lockfile_path,
        "lockfile_hash": lockfile_hash,
        "artifacts": artifacts,
    }

    # Serialize to JSON with nice formatting
    content = json.dumps(metadata, indent=2, sort_keys=True)

    # Determine output path: lockfile.lock -> lockfile_clojure_namespaces.json
    lockfile_name = Path(lockfile_path).stem  # Remove .lock extension
    output_path = f"{Path(lockfile_path).parent}/{lockfile_name}_clojure_namespaces.json"

    return FileContent(
        path=output_path,
        content=content.encode('utf-8'),
    )


def rules():
    return collect_rules()
