# Implementation Plan: Three AOT Compilation Modes

**Date**: 2025-12-05
**Status**: Complete

## Implementation Progress

| Phase | Description | Status |
|-------|-------------|--------|
| Phase 1 | Add `:none` mode for source-only uberjars | ✅ Complete |
| Phase 2 | Update documentation and help text | ✅ Complete |
| Phase 3 | Add tests for new mode | ✅ Complete |

## Plan Overview

Align our AOT compilation options with Leiningen's three modes:

1. **AOT nothing** (`:none`) - Source-only JAR, no compilation
2. **AOT everything** (`:all`) - Compile all project namespaces
3. **AOT specific namespaces** (explicit list) - Compile only listed namespaces

Currently, we default to compiling the main namespace (which transitively compiles its dependencies). This differs from Leiningen's default of no AOT.

## Problem Statement

### Current Behavior

| Mode | Configuration | Behavior |
|------|--------------|----------|
| Default | `aot=()` (empty) | Compiles main namespace + transitive deps |
| All | `aot=[":all"]` | Compiles all project namespaces |
| Specific | `aot=["ns1", "ns2"]` | Compiles listed namespaces |

### Leiningen Behavior

| Mode | Configuration | Behavior |
|------|--------------|----------|
| Default | No `:aot` key | Source-only JAR (no AOT) |
| All | `:aot :all` | Compiles all project namespaces |
| Specific | `:aot [ns1 ns2]` | Compiles listed namespaces |

### Why This Matters

1. **Third-party AOT issues**: When AOT compiling, Clojure transitively compiles all required namespaces. If third-party libraries are compiled, their `.class` files can cause issues:
   - Protocol/record identity mismatches between AOT'd and non-AOT'd code
   - Bundling classes that break library loading assumptions
   - Larger JAR sizes than necessary

2. **Our current mitigation**: We use a two-pass strategy where dependency JARs are extracted last, overwriting transitively-compiled third-party classes. This works but adds complexity.

3. **Source-only option**: Some users want truly source-only uberjars that defer all compilation to runtime. This avoids all AOT-related issues at the cost of slower startup.

---

## Proposed Solution

Add a new special value `:none` to the `aot` field that skips AOT compilation entirely, creating a source-only uberjar.

### Key Design Decision: Execution Model

After review, we identified that the naive approach of using `clojure.main` as Main-Class won't work because `java -jar` passes arguments to the main method, not to the JVM.

**Chosen approach**: Source-only JARs are NOT directly executable with `java -jar`. Users must run:

```bash
java -cp app.jar clojure.main -m my.app.core
```

This is consistent with Leiningen's behavior for non-AOT uberjars. The tradeoff is explicitly documented.

**Rationale**:
- Keeps the implementation simple (no custom launcher classes)
- Avoids partial AOT which could introduce subtle issues
- Aligns with Leiningen's behavior
- Users who need `java -jar` execution can use the default mode (AOT main only)

### API Design

```python
clojure_deploy_jar(
    name="my-app",
    main="my.app.core",

    # Mode 1: AOT nothing (new!)
    aot=[":none"],

    # Mode 2: AOT main only (current default - unchanged)
    # aot=(),  # or omit entirely

    # Mode 3: AOT everything
    # aot=[":all"],

    # Mode 4: AOT specific namespaces
    # aot=["my.app.core", "my.app.util"],
)
```

### Why Keep Current Default?

Our default (AOT main only) differs from Leiningen's default (no AOT). We keep our default because:

1. **Backward compatibility**: Existing users expect executable JARs
2. **Pragmatic choice**: Most users want `java -jar` to work
3. **Explicit opt-in**: Users who want source-only can explicitly use `:none`

---

## Implementation Plan

### Phase 1: Add `:none` Mode for Source-Only Uberjars

**Goal**: Implement the new AOT mode that skips compilation entirely.

**Files to modify**:
1. `pants-plugins/clojure_backend/target_types.py`
2. `pants-plugins/clojure_backend/goals/package.py`

**Tasks**:

#### 1.1 Update field documentation in `target_types.py`:

```python
class ClojureAOTNamespacesField(StringSequenceField):
    alias = "aot"
    help = (
        "Namespaces to AOT compile. Options:\n"
        "- [':none']: No AOT compilation (source-only JAR, not directly executable)\n"
        "- Empty (default): Compile only main namespace (transitive)\n"
        "- [':all']: Compile all project namespaces from dependencies\n"
        "- ['ns1', 'ns2']: Compile specific namespaces\n\n"
        "Note: AOT compilation is transitive - compiling a namespace will "
        "automatically compile all namespaces it requires.\n\n"
        "The ':none' mode creates a source-only JAR that defers all compilation "
        "to runtime. This avoids AOT-related issues but:\n"
        "- Results in slower startup (compilation happens at runtime)\n"
        "- JAR is not directly executable with 'java -jar'\n"
        "- Run with: java -cp app.jar clojure.main -m my.app.core"
    )
    default = ()  # Empty = main namespace only (transitive)
```

#### 1.2 Add validation in `package.py` (early in the rule):

```python
# Validate aot field values
aot_field = field_set.aot
if ":none" in aot_field.value and len(aot_field.value) > 1:
    raise ValueError(
        f"':none' cannot be combined with other AOT values. "
        f"Got: {aot_field.value}"
    )
```

#### 1.3 Add `:none` handling in `package.py` (around line 141-152):

```python
# Determine which namespaces to compile
namespaces_to_compile: tuple[str, ...]
skip_aot = ":none" in aot_field.value

if skip_aot:
    # No AOT compilation - source-only JAR
    namespaces_to_compile = ()
elif ":all" in aot_field.value:
    # Compile all Clojure namespaces in the project
    namespaces_to_compile = tuple(sorted(set(namespace_analysis.namespaces.values())))
elif not aot_field.value:
    # Default: compile just the main namespace (transitive)
    namespaces_to_compile = (main_namespace,)
else:
    # Explicit list of namespaces
    namespaces_to_compile = tuple(aot_field.value)
```

#### 1.4 Skip gen-class validation for :none mode (around line 180-199):

```python
# Only validate gen-class if we're doing AOT compilation
if not skip_aot:
    # Existing gen-class validation code
    ns_with_gen_class = re.search(
        r'\(ns\s+[\w.-]+.*?\(:gen-class',
        main_source_file,
        re.DOTALL,
    )
    if not ns_with_gen_class:
        raise ValueError(...)
```

#### 1.5 Skip AOT compilation when :none (around line 235-246):

```python
if skip_aot:
    # No AOT - use empty digest for compiled classes
    from pants.engine.fs import EMPTY_DIGEST
    compiled_classes = CompiledClojureClasses(
        digest=EMPTY_DIGEST,
        classpath_entry=None,
    )
else:
    compiled_classes = await Get(
        CompiledClojureClasses,
        CompileClojureAOTRequest(...),
    )
```

#### 1.6 Add first-party source files to JAR for :none mode (CRITICAL)

**Issue**: Currently, first-party source files are NOT added to the JAR. Only AOT'd classes and dependency JAR contents are included. For `:none` mode, we must include source files.

Add after the "Step 1: Add first-party AOT-compiled classes" section (~line 356):

```python
# Step 1.5: Add first-party source files when skip_aot=True
# (When AOT is enabled, sources come from dependency JARs or are replaced by classes)
if skip_aot:
    # Get source files for first-party targets
    first_party_source_fields = [
        tgt[ClojureSourceField] if tgt.has_field(ClojureSourceField)
        else tgt[ClojureTestSourceField]
        for tgt in clojure_source_targets
        if tgt.address not in provided_deps.addresses
    ]

    if first_party_source_fields:
        first_party_sources = await Get(
            SourceFiles,
            SourceFilesRequest(first_party_source_fields, for_sources_types=(ClojureSourceField, ClojureTestSourceField)),
        )
        first_party_source_contents = await Get(DigestContents, Digest, first_party_sources.snapshot.digest)

        for file_content in first_party_source_contents:
            # Strip source root to get correct classpath location
            # e.g., "src/my/app/core.clj" -> "my/app/core.clj"
            arcname = strip_source_root(file_content.path)
            if arcname not in added_entries:
                jar.writestr(arcname, file_content.content)
                added_entries.add(arcname)

        logger.info(f"Added {len(first_party_source_contents)} first-party source files")
```

**Note**: We need to handle source root stripping. This may require using existing `SourceFiles` with `for_sources_types` or the `StrippedSourceFiles` request.

#### 1.7 Handle manifest for source-only JARs:

For `:none` mode, the manifest won't have a usable Main-Class (no compiled class exists). We have options:

**Option A (Recommended)**: Use main namespace name as Main-Class anyway, but document it won't work:
```python
if skip_aot:
    # Source-only JAR - not directly executable
    # Main-Class is set for documentation purposes but won't work with java -jar
    main_class_name = main_namespace.replace('-', '_').replace('.', '/')
    manifest_content = f"""\
Manifest-Version: 1.0
Main-Namespace: {main_namespace}
Created-By: Pants Build System
X-Source-Only: true
"""
else:
    # Standard manifest with executable main class
    manifest_content = f"""\
Manifest-Version: 1.0
Main-Class: {main_class_name}
Created-By: Pants Build System
"""
```

**Option B**: Omit Main-Class entirely and add a custom attribute.

We'll go with Option A since it provides useful metadata.

**Validation**:
- Test that `:none` creates a JAR with source files but no first-party `.class` files
- Test that `:none` combined with other values raises an error
- Test that gen-class is not required for `:none`
- Existing tests still pass

---

### Phase 2: Update Documentation and Help Text

**Goal**: Clearly document all four AOT modes and their trade-offs.

**Files to modify**:
1. `pants-plugins/clojure_backend/target_types.py` - field help text (done in Phase 1)
2. `docs/aot_compilation.md` - comprehensive documentation

**Tasks**:

#### 2.1 Update `docs/aot_compilation.md` with new section:

```markdown
## AOT Modes

### Mode 1: No AOT (`:none`)

```python
clojure_deploy_jar(
    name="app",
    main="my.app.core",
    aot=[":none"],
)
```

Creates a source-only JAR. All Clojure code is compiled at runtime when
the application starts.

**Running the JAR:**
```bash
# Source-only JARs are NOT directly executable
# This will NOT work:
java -jar app.jar  # ERROR: no main manifest attribute

# Instead, run with:
java -cp app.jar clojure.main -m my.app.core
```

**Pros:**
- No AOT-related issues (protocol identity, record equality, etc.)
- Simpler build process
- Works with all libraries regardless of their AOT compatibility
- Smaller JAR size (no duplicate .class files)

**Cons:**
- Slower startup (compilation happens at runtime, can be 10-30+ seconds)
- Not directly executable with `java -jar`
- Requires Clojure runtime to be bundled

**When to use:**
- Libraries that have known AOT issues
- Development/testing where startup time is acceptable
- When you need maximum compatibility

### Mode 2: AOT Main Only (default)

```python
clojure_deploy_jar(
    name="app",
    main="my.app.core",
    # aot=() or omit
)
```

Compiles the main namespace and all its transitive dependencies.

**Running the JAR:**
```bash
java -jar app.jar
```

**Pros:**
- Fast startup for the main execution path
- JAR is directly executable
- Good balance of startup speed and compatibility

**Cons:**
- Transitively compiles third-party code (mitigated by our two-pass strategy)
- Requires `(:gen-class)` in main namespace

**When to use:**
- Most applications (recommended default)
- When you need `java -jar` execution

### Mode 3: AOT All (`:all`)

```python
clojure_deploy_jar(
    name="app",
    main="my.app.core",
    aot=[":all"],
)
```

Compiles all project namespaces.

**Pros:**
- Fastest possible startup
- All code paths pre-compiled

**Cons:**
- May cause protocol/record identity issues
- Larger build output

**When to use:**
- Performance-critical applications
- When all dependencies are AOT-compatible
- Batch processing jobs

### Mode 4: AOT Specific Namespaces

```python
clojure_deploy_jar(
    name="app",
    main="my.app.core",
    aot=["my.app.core", "my.app.critical"],
)
```

Compiles only the specified namespaces.

**Pros:**
- Fine-grained control over what gets compiled
- Can target hot code paths

**Cons:**
- Requires manual namespace management
- Namespace dependencies may pull in more than expected

**When to use:**
- When you need specific namespaces compiled but want to avoid full `:all`
- Performance tuning specific paths
```

#### 2.2 Add comparison with Leiningen:

```markdown
## Comparison with Leiningen

| Feature | Leiningen | Pants Clojure |
|---------|-----------|---------------|
| No AOT | Default (omit `:aot`) | `aot=[":none"]` |
| AOT main only | `:aot [main.ns]` | Default (omit `aot`) |
| AOT all | `:aot :all` | `aot=[":all"]` |
| AOT specific | `:aot [ns1 ns2]` | `aot=["ns1", "ns2"]` |

**Why different defaults?**

Leiningen defaults to no AOT because it prioritizes compatibility and
follows a more traditional Clojure development workflow.

Pants defaults to AOT main because:
- Most users expect `java -jar` to work
- Faster startup is typically desired for deployed applications
- Users can explicitly opt out with `:none`
```

---

### Phase 3: Add Tests for New Mode

**Goal**: Comprehensive test coverage for the `:none` mode.

**Files to modify**:
1. `pants-plugins/tests/test_target_types.py`
2. `pants-plugins/tests/test_package_clojure_deploy_jar.py`

**Tasks**:

#### 3.1 Add target type test in `test_target_types.py`:

```python
def test_clojure_deploy_jar_with_aot_none(rule_runner: RuleRunner) -> None:
    """Test creating a clojure_deploy_jar with aot=':none'."""
    rule_runner.write_files({
        "src/BUILD": dedent("""\
            clojure_source(name="core", source="core.clj")

            clojure_deploy_jar(
                name="app",
                main="my.app.core",
                aot=[":none"],
                dependencies=[":core"],
            )
            """),
        "src/core.clj": "(ns my.app.core) (defn -main [& args] (println \"Hello\"))",
    })

    target = rule_runner.get_target(Address("src", target_name="app"))
    assert ":none" in target[ClojureAOTNamespacesField].value
```

#### 3.2 Add validation test:

```python
def test_clojure_deploy_jar_aot_none_cannot_combine(rule_runner: RuleRunner) -> None:
    """Test that :none cannot be combined with other AOT values."""
    rule_runner.write_files({
        "src/BUILD": dedent("""\
            clojure_source(name="core", source="core.clj")

            clojure_deploy_jar(
                name="app",
                main="my.app.core",
                aot=[":none", ":all"],  # Invalid combination
                dependencies=[":core"],
            )
            """),
        "src/core.clj": "(ns my.app.core (:gen-class)) (defn -main [] nil)",
    })

    with pytest.raises(ValueError, match="':none' cannot be combined"):
        rule_runner.request(BuiltPackage, [field_set])
```

#### 3.3 Add packaging test in `test_package_clojure_deploy_jar.py`:

```python
def test_package_deploy_jar_with_aot_none(rule_runner: RuleRunner) -> None:
    """Test packaging with aot=':none' creates source-only JAR."""
    setup_rule_runner(rule_runner)
    rule_runner.write_files({
        "src/app/BUILD": dedent("""\
            clojure_source(name="core", source="core.clj")

            clojure_deploy_jar(
                name="app",
                main="app.core",
                aot=[":none"],
                dependencies=[":core"],
            )
            """),
        # Note: no (:gen-class) - not required for :none
        "src/app/core.clj": "(ns app.core) (defn -main [& args] (println \"Hello\"))",
    })

    field_set = ClojureDeployJarFieldSet.create(
        rule_runner.get_target(Address("src/app", target_name="app"))
    )
    result = rule_runner.request(BuiltPackage, [field_set])

    # Verify JAR was created
    assert len(result.artifacts) == 1

    # Extract and examine JAR contents
    jar_contents = rule_runner.request(DigestContents, [result.digest])
    jar_data = next(fc for fc in jar_contents if fc.path.endswith('.jar'))

    with zipfile.ZipFile(io.BytesIO(jar_data.content)) as jar:
        entries = jar.namelist()

        # Should have first-party source files
        assert any(e == 'app/core.clj' or e.endswith('/core.clj') for e in entries), \
            f"Expected source file not found in {entries}"

        # Should NOT have first-party compiled classes
        first_party_classes = [e for e in entries if e.startswith('app/') and e.endswith('.class')]
        assert not first_party_classes, \
            f"Unexpected first-party classes: {first_party_classes}"

        # Should have Clojure runtime (from dependency JARs)
        assert any('clojure/core' in e for e in entries), \
            "Clojure runtime not found in JAR"

        # Check manifest
        manifest = jar.read('META-INF/MANIFEST.MF').decode()
        assert 'X-Source-Only: true' in manifest or 'Main-Namespace' in manifest
```

#### 3.4 Add test for gen-class not required with :none:

```python
def test_package_deploy_jar_aot_none_no_gen_class_required(rule_runner: RuleRunner) -> None:
    """Test that :none mode doesn't require (:gen-class)."""
    setup_rule_runner(rule_runner)
    rule_runner.write_files({
        "src/app/BUILD": dedent("""\
            clojure_source(name="core", source="core.clj")

            clojure_deploy_jar(
                name="app",
                main="app.core",
                aot=[":none"],
                dependencies=[":core"],
            )
            """),
        # Note: NO (:gen-class) in ns declaration
        "src/app/core.clj": "(ns app.core)\n\n(defn -main [& args]\n  (println \"Hi\"))",
    })

    field_set = ClojureDeployJarFieldSet.create(
        rule_runner.get_target(Address("src/app", target_name="app"))
    )

    # Should NOT raise ValueError about missing gen-class
    result = rule_runner.request(BuiltPackage, [field_set])
    assert len(result.artifacts) == 1
```

#### 3.5 Add test verifying .cljc files are included:

```python
def test_package_deploy_jar_aot_none_includes_cljc(rule_runner: RuleRunner) -> None:
    """Test that :none mode includes .cljc files."""
    setup_rule_runner(rule_runner)
    rule_runner.write_files({
        "src/app/BUILD": dedent("""\
            clojure_sources(name="lib")

            clojure_deploy_jar(
                name="app",
                main="app.core",
                aot=[":none"],
                dependencies=[":lib"],
            )
            """),
        "src/app/core.clj": "(ns app.core (:require [app.util]))\n(defn -main [] (app.util/greet))",
        "src/app/util.cljc": "(ns app.util)\n(defn greet [] (println \"Hello\"))",
    })

    # ... verify both .clj and .cljc are in the JAR
```

---

## Testing Strategy

### Unit Tests
- Field value parsing for `:none`
- Validation that `:none` cannot combine with other values
- Skip of gen-class validation logic

### Integration Tests
- Source-only JAR creation
- First-party `.clj` and `.cljc` files included
- No first-party `.class` files
- Manifest has correct attributes
- Provided dependencies still excluded

### Manual Testing
```bash
# Build source-only JAR
pants package //projects/example:hello-jar-source-only

# Verify contents
unzip -l dist/hello-jar-source-only.jar | grep -E '\.(class|clj|cljc)$'

# Verify first-party source is there
unzip -p dist/hello-jar-source-only.jar hello/core.clj

# Verify first-party classes are NOT there
unzip -l dist/hello-jar-source-only.jar | grep 'hello/.*\.class' && echo "FAIL: classes found"

# Run it (correct way)
java -cp dist/hello-jar-source-only.jar clojure.main -m hello.core

# This should fail or behave unexpectedly
java -jar dist/hello-jar-source-only.jar  # Expected: error or no main class
```

---

## Success Criteria

1. [ ] `:none` mode creates JAR with first-party source files (`.clj`, `.cljc`)
2. [ ] `:none` mode creates JAR with NO first-party `.class` files
3. [ ] `:none` cannot be combined with other AOT values (validation error)
4. [ ] `(:gen-class)` is not required for `:none` mode
5. [ ] Manifest indicates source-only mode
6. [ ] JAR can be run with `java -cp app.jar clojure.main -m namespace`
7. [ ] Documentation clearly explains all modes and trade-offs
8. [ ] All existing tests pass
9. [ ] New tests cover `:none` mode comprehensively

---

## Potential Issues and Mitigations

### Issue 1: Source Root Stripping

**Problem**: First-party source files need their source roots stripped to be placed correctly in the JAR (e.g., `src/my/app/core.clj` → `my/app/core.clj`).

**Mitigation**: Use Pants' `StrippedSourceFiles` or ensure source files are requested with proper handling. The existing namespace analysis already handles this for determining namespaces.

### Issue 2: Slow Startup Time

**Problem**: Source-only JARs can take 10-30+ seconds to start due to runtime compilation.

**Mitigation**: Document this clearly. Users choosing `:none` are explicitly accepting this trade-off.

### Issue 3: Classpath Execution Complexity

**Problem**: Users must remember to use `java -cp ... clojure.main -m` instead of `java -jar`.

**Mitigation**:
- Document clearly in help text and docs
- Add custom manifest attribute for tooling
- Consider a wrapper script generator (future enhancement)

### Issue 4: Provided Dependencies with :none

**Problem**: Should provided dependencies still be excluded from source-only JARs?

**Mitigation**: Yes, the same logic applies. If a dependency is "provided", it should be excluded from the JAR regardless of AOT mode. The existing filtering will work because it operates on JAR contents, not classes.

---

## References

- Leiningen AOT documentation: https://leiningen.org/tutorial.html
- Leiningen FAQ on AOT: https://leiningen.org/faq.html
- Leiningen sample.project.clj: https://github.com/technomancy/leiningen/blob/master/sample.project.clj
- Current AOT implementation: `pants-plugins/clojure_backend/goals/package.py`
- AOT compilation docs: `docs/aot_compilation.md`
