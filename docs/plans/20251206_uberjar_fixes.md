# Implementation Plan: Fix Uberjar gen-class :name Detection

**Date**: 2025-12-06
**Status**: Draft

## Executive Summary

After analyzing Leiningen, tools.build, and the current pants-clojure implementation, this plan addresses a critical bug where `(:gen-class :name X)` declarations result in the custom class being excluded from the final JAR, causing guaranteed runtime failures.

## Research Findings

### How Leiningen Handles Uberjars

1. **AOT Compilation**: Supports `:aot :all`, explicit namespace list, or no AOT
2. **Third-party Classes**: Included from dependency JARs (not from AOT output)
3. **Provided Dependencies**: Uses profile metadata `{:pom-scope :provided}` - profiles excluded before dependency resolution
4. **Uberjar Build**: Creates project JAR first (with AOT classes), then merges with ALL dependency JARs

### How tools.build Handles Uberjars

1. **Dual Basis Pattern**:
   ```clojure
   compile-basis (b/create-basis)                    ;; Full basis for compilation
   uber-basis (b/create-basis {:aliases [:uberjar]}) ;; Excludes provided via alias
   ```
2. **AOT Compilation**: `compile-clj` with options like `:direct-linking true`
3. **Uberjar Creation**: `uber` combines class-dir + basis deps + sources
4. **Conflict Resolution**: Strategies like `:ignore` (default), `:overwrite`, `:append`

### Current pants-clojure Approach (Correct)

1. **AOT Strategy**: Compile main transitively, then filter to first-party only
2. **Third-party Handling**: Discard AOT classes, use JAR contents (protocol-safe!)
3. **Provided Dependencies**: Coordinate-based matching with Maven transitive expansion
4. **First-party Detection**: Based on namespace analysis of clojure_source targets

**Our approach is SAFER than lein/tools.build for protocol identity issues**, because we ensure third-party classes always come from their original JARs.

## Critical Bug: gen-class :name Classes Missing from JAR

### The Problem

When a namespace uses `(:gen-class :name com.example.MyApp)`:

```clojure
(ns my.app.core
  (:gen-class :name com.example.MyApp))

(defn -main [& args]
  (println "Hello"))
```

The AOT compiler generates:
- `my/app/core__init.class` - namespace initialization (included correctly)
- `my/app/core$fn__xxx.class` - anonymous functions (included correctly)
- `com/example/MyApp.class` - the custom named class (**EXCLUDED!**)

### Why It's Excluded

The `is_first_party_class` function at `package.py:301-309` only checks if a class path matches a namespace path:

```python
def is_first_party_class(arcname: str) -> bool:
    class_path = arcname[:-6]  # Remove .class
    base_class_path = class_path.split('$')[0]
    if base_class_path.endswith('__init'):
        base_class_path = base_class_path[:-6]
    return base_class_path in first_party_namespace_paths
```

For `com/example/MyApp.class`:
- `class_path = "com/example/MyApp"`
- `base_class_path = "com/example/MyApp"` (no $ or __init)
- `first_party_namespace_paths = {"my/app/core"}` (from namespace analysis)
- Returns `False` - class is excluded!

### Impact: Guaranteed Runtime Failure

The manifest correctly sets `Main-Class: com.example.MyApp` (lines 204-211 extract gen-class :name), but the class isn't in the JAR:

```bash
$ java -jar app.jar
Error: Could not find or load main class com.example.MyApp
```

### Why Existing Tests Don't Catch This

The test `test_package_deploy_jar_with_custom_gen_class_name` only verifies that packaging succeeds and the manifest is correct. It doesn't inspect JAR contents to verify the custom class is present.

## Implementation Plan

### Phase 1: Fix gen-class :name Detection [DONE]

**Goal**: Include classes generated by `(:gen-class :name X)` in the JAR.

**Files to modify**:
- `pants-plugins/clojure_backend/goals/package.py`

**Tasks**:

#### 1.1 Extract gen-class :name from ALL first-party source files

The existing code at lines 204-211 already extracts gen-class :name from the main source file. We need to do this for ALL first-party sources:

```python
# After building first_party_namespace_paths (around line 137)

# Also track gen-class :name declarations from all first-party sources
first_party_gen_class_paths: set[str] = set()

for file_content in digest_contents:
    source_content = file_content.content.decode("utf-8")
    # Look for (:gen-class :name X) pattern
    # Use the same pattern already used at line 205
    gen_class_name_match = re.search(
        r'\(:gen-class\s+:name\s+([a-zA-Z][\w.]*)',
        source_content,
        re.DOTALL,
    )
    if gen_class_name_match:
        class_name = gen_class_name_match.group(1)
        # Convert com.example.MyApp -> com/example/MyApp
        class_path = class_name.replace('.', '/')
        first_party_gen_class_paths.add(class_path)

logger.debug(f"First-party gen-class names: {first_party_gen_class_paths}")
```

#### 1.2 Update is_first_party_class to check gen-class paths

```python
def is_first_party_class(arcname: str) -> bool:
    """Check if a class file belongs to a first-party namespace or gen-class."""
    if not first_party_namespace_paths:
        return True  # Fallback: include all if no analysis available

    class_path = arcname[:-6]  # Remove .class
    base_class_path = class_path.split('$')[0]  # Handle inner classes
    if base_class_path.endswith('__init'):
        base_class_path = base_class_path[:-6]

    # Check namespace paths (handles init, fn, record, protocol classes)
    if base_class_path in first_party_namespace_paths:
        return True

    # Check gen-class :name paths (exact match for custom named classes)
    # Note: gen-class :name classes don't have inner classes or __init suffix
    if class_path in first_party_gen_class_paths:
        return True

    return False
```

**Note**: The gen-class :name check uses `class_path` not `base_class_path` because custom named classes don't have $ suffixes or __init suffixes - they're standalone classes.

---

### Phase 2: Add Manifest Validation [DONE]

**Goal**: Fail fast with helpful error if Main-Class is missing from JAR.

**Files to modify**:
- `pants-plugins/clojure_backend/goals/package.py`

**Tasks**:

#### 2.1 Validate Main-Class exists in JAR

After building the JAR (around line 443), add validation:

```python
# Validate that the manifest's Main-Class is actually in the JAR
if not skip_aot:
    main_class_path = main_class_name.replace('.', '/') + '.class'
    if main_class_path not in added_entries:
        raise ValueError(
            f"Main class '{main_class_name}' was not found in the JAR.\n\n"
            f"This usually means:\n"
            f"  1. The namespace uses (:gen-class :name {main_class_name}) but the class wasn't detected\n"
            f"  2. The main namespace wasn't properly compiled\n\n"
            f"Expected class file: {main_class_path}\n"
            f"First-party namespace paths: {sorted(first_party_namespace_paths)}\n"
            f"First-party gen-class paths: {sorted(first_party_gen_class_paths)}\n\n"
            f"If using (:gen-class :name X), ensure the pattern is on a single line "
            f"and follows the format: (:gen-class :name fully.qualified.ClassName)"
        )
```

---

### Phase 3: Fix Tests and Add Coverage [DONE]

**Goal**: Ensure tests actually verify JAR contents.

**Files to modify**:
- `pants-plugins/tests/test_package_clojure_deploy_jar.py`

**Tasks**:

#### 3.1 Fix test_package_deploy_jar_with_custom_gen_class_name

The existing test only verifies packaging succeeds. Update it to verify the custom class is in the JAR:

```python
def test_package_deploy_jar_with_custom_gen_class_name(rule_runner: RuleRunner) -> None:
    """Test that (:gen-class :name X) generates X.class in JAR."""
    setup_rule_runner(rule_runner)
    rule_runner.write_files({
        "src/app/BUILD": dedent("""\
            clojure_source(name="core", source="core.clj")
            clojure_deploy_jar(
                name="app",
                main="app.core",
                dependencies=[":core"],
            )
            """),
        "src/app/core.clj": dedent("""\
            (ns app.core
              (:gen-class :name com.example.MyApp))
            (defn -main [& args]
              (println "Hello"))
            """),
    })

    # Build the JAR
    field_set = ClojureDeployJarFieldSet.create(
        rule_runner.get_target(Address("src/app", target_name="app"))
    )
    result = rule_runner.request(BuiltPackage, [field_set])
    assert len(result.artifacts) == 1

    # Extract and verify JAR contents
    jar_contents = rule_runner.request(DigestContents, [result.digest])
    jar_data = next(fc for fc in jar_contents if fc.path.endswith('.jar'))

    with zipfile.ZipFile(io.BytesIO(jar_data.content)) as jar:
        entries = set(jar.namelist())

        # Verify namespace init class is present
        assert 'app/core__init.class' in entries, \
            f"Namespace init class not found. Entries: {sorted(entries)}"

        # Verify custom gen-class :name class is present
        assert 'com/example/MyApp.class' in entries, \
            f"Custom gen-class class not found. Entries: {sorted(entries)}"

        # Verify manifest has correct Main-Class
        manifest = jar.read('META-INF/MANIFEST.MF').decode()
        assert 'Main-Class: com.example.MyApp' in manifest, \
            f"Wrong Main-Class in manifest: {manifest}"
```

#### 3.2 Add test for multiple gen-class declarations

```python
def test_package_deploy_jar_multiple_gen_class_names(rule_runner: RuleRunner) -> None:
    """Test that multiple (:gen-class :name) declarations all get included."""
    setup_rule_runner(rule_runner)
    rule_runner.write_files({
        "src/app/BUILD": dedent("""\
            clojure_sources(name="lib")
            clojure_deploy_jar(
                name="app",
                main="app.core",
                dependencies=[":lib"],
            )
            """),
        "src/app/core.clj": dedent("""\
            (ns app.core
              (:gen-class :name com.example.Main))
            (defn -main [& args] nil)
            """),
        "src/app/helper.clj": dedent("""\
            (ns app.helper
              (:gen-class :name com.example.Helper))
            (defn help [] nil)
            """),
    })

    # Build and verify both custom classes are present
    field_set = ClojureDeployJarFieldSet.create(
        rule_runner.get_target(Address("src/app", target_name="app"))
    )
    result = rule_runner.request(BuiltPackage, [field_set])

    jar_contents = rule_runner.request(DigestContents, [result.digest])
    jar_data = next(fc for fc in jar_contents if fc.path.endswith('.jar'))

    with zipfile.ZipFile(io.BytesIO(jar_data.content)) as jar:
        entries = set(jar.namelist())
        assert 'com/example/Main.class' in entries
        assert 'com/example/Helper.class' in entries
```

#### 3.3 Add test for gen-class without :name (baseline)

```python
def test_package_deploy_jar_gen_class_without_name(rule_runner: RuleRunner) -> None:
    """Test that standard (:gen-class) without :name works correctly."""
    setup_rule_runner(rule_runner)
    rule_runner.write_files({
        "src/app/BUILD": dedent("""\
            clojure_source(name="core", source="core.clj")
            clojure_deploy_jar(
                name="app",
                main="app.core",
                dependencies=[":core"],
            )
            """),
        "src/app/core.clj": dedent("""\
            (ns app.core
              (:gen-class))
            (defn -main [& args]
              (println "Hello"))
            """),
    })

    field_set = ClojureDeployJarFieldSet.create(
        rule_runner.get_target(Address("src/app", target_name="app"))
    )
    result = rule_runner.request(BuiltPackage, [field_set])

    jar_contents = rule_runner.request(DigestContents, [result.digest])
    jar_data = next(fc for fc in jar_contents if fc.path.endswith('.jar'))

    with zipfile.ZipFile(io.BytesIO(jar_data.content)) as jar:
        entries = set(jar.namelist())

        # Standard gen-class generates namespace-named class
        assert 'app/core.class' in entries, \
            f"Standard gen-class class not found. Entries: {sorted(entries)}"
        assert 'app/core__init.class' in entries

        manifest = jar.read('META-INF/MANIFEST.MF').decode()
        assert 'Main-Class: app.core' in manifest
```

---

### Phase 4: Documentation Updates [DONE]

**Goal**: Document gen-class handling.

**Files to modify**:
- `docs/aot_compilation.md`

**Tasks**:

#### 4.1 Add section on gen-class

```markdown
## Using (:gen-class :name)

You can specify a custom class name using `:gen-class :name`:

```clojure
(ns my.app.core
  (:gen-class :name com.example.MyApp))
```

The manifest will use `com.example.MyApp` as the Main-Class, and this class
will be correctly included in the uberjar.

**Note**: The `:gen-class :name` declaration should be on a single line for
proper detection. Multi-line gen-class forms with complex options may not be
detected correctly.
```

---

## Not Changing: First-Party Detection Logic

The plan reviewer correctly identified that the original "Bug 1" (first-party detection including all transitive clojure_source targets) is **NOT a bug**:

> In Pants, `clojure_source` targets in the transitive closure are ALL first-party from the build perspective. The distinction isn't "project vs third-party" but "has a JAR vs doesn't have a JAR".
>
> - Code from `jvm_artifact` will have JARs that override AOT (correct current behavior)
> - Code from `clojure_source` won't have JARs, so AOT must be included (correct current behavior)

The current implementation is correct for monorepo setups where shared libraries are defined as `clojure_source` targets. No changes needed.

## Comparison with Leiningen/tools.build

| Feature | Leiningen | tools.build | pants-clojure |
|---------|-----------|-------------|---------------|
| Third-party AOT | Kept | Kept (default) | Discarded (safer) |
| Third-party JARs | Extracted | Extracted | Extracted |
| Provided deps | Profile removal | Alias-based basis | Coordinate matching |
| gen-class :name | Included | Included | **Fixed in this plan** |
| Protocol safety | Risk of issues | Risk of issues | Safe (JAR classes used) |

## Testing Strategy

### Unit Tests
- gen-class :name extraction regex
- Manifest validation

### Integration Tests
- JAR with gen-class :name (verify class is present)
- JAR with multiple gen-class :name declarations
- JAR with standard gen-class (no :name)

### Manual Tests
```bash
# Build JAR with custom gen-class
pants package //path/to:my-deploy-jar

# Verify custom class is present
jar tf dist/path.to/my-deploy-jar.jar | grep -i myapp

# Verify it runs
java -jar dist/path.to/my-deploy-jar.jar
```

## Success Criteria

1. [ ] Classes from `(:gen-class :name X)` are included in JAR
2. [ ] Manifest validation catches missing Main-Class
3. [ ] Test verifies custom class is in JAR (not just packaging succeeds)
4. [ ] Multiple gen-class :name in same project all included
5. [ ] All existing tests pass
6. [ ] Documentation updated

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Regex doesn't handle edge cases | Medium | Medium | Document limitations, fail safely with validation |
| Performance impact from extra parsing | Low | Low | Reuses existing digest_contents |
| Breaking change | None | N/A | This is a bug fix, enables previously-broken use case |

## References

- Leiningen source: `/Users/hopper/workspace/clojure/leiningen`
- tools.deps source: `/Users/hopper/workspace/clojure/tools.deps`
- tools.build API: https://clojure.github.io/tools.build/
- Current implementation: `pants-plugins/clojure_backend/goals/package.py`
- Plan reviewer feedback: Incorporated above
